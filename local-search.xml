<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>windows和linux防火墙的配置</title>
    <link href="/2023/09/10/%E8%BF%90%E7%BB%B4%E6%95%85%E4%BA%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows%E5%92%8Clinux%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    <url>/2023/09/10/%E8%BF%90%E7%BB%B4%E6%95%85%E4%BA%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows%E5%92%8Clinux%E9%98%B2%E7%81%AB%E5%A2%99/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-防火墙简介"><a href="#0x00-防火墙简介" class="headerlink" title="0x00 防火墙简介"></a>0x00 防火墙简介</h2><h2 id="0x01-windows防火墙"><a href="#0x01-windows防火墙" class="headerlink" title="0x01 windows防火墙"></a>0x01 windows防火墙</h2><h2 id="0x02-linux防火墙"><a href="#0x02-linux防火墙" class="headerlink" title="0x02 linux防火墙"></a>0x02 linux防火墙</h2>]]></content>
    
    
    <categories>
      
      <category>运维故事</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iptables</tag>
      
      <tag>防火墙</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AWS-SAP考证笔记（1）计算产品</title>
    <link href="/2023/09/10/%E8%80%83%E8%AF%81%E4%B9%8B%E8%B7%AF/AWS-SAP/aws-sap%E8%80%83%E8%AF%81%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%E5%AD%98%E5%82%A8%E4%BA%A7%E5%93%81/"/>
    <url>/2023/09/10/%E8%80%83%E8%AF%81%E4%B9%8B%E8%B7%AF/AWS-SAP/aws-sap%E8%80%83%E8%AF%81%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%E5%AD%98%E5%82%A8%E4%BA%A7%E5%93%81/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Amazon-EC2-Auto-Scaling"><a href="#一、Amazon-EC2-Auto-Scaling" class="headerlink" title="一、Amazon EC2 Auto Scaling"></a>一、Amazon EC2 Auto Scaling</h2><h3 id="1、什么是-Amazon-EC2-Auto-Scaling？"><a href="#1、什么是-Amazon-EC2-Auto-Scaling？" class="headerlink" title="1、什么是 Amazon EC2 Auto Scaling？"></a>1、什么是 Amazon EC2 Auto Scaling？</h3><p>Amazon EC2 Auto Scaling 是一项完全托管的服务，可自动启动或终止 Amazon EC2 实例，以帮助确保您拥有适当数量的 Amazon EC2 实例来处理应用程序负载。Amazon EC2 Auto Scaling 通过对 EC2 实例进行队列管理，检测并替换运行状况异常的实例，并根据您定义的条件自动扩展或缩减 Amazon EC2 容量，从而帮助您保持应用程序的可用性。</p><h3 id="2、使用场景"><a href="#2、使用场景" class="headerlink" title="2、使用场景"></a>2、使用场景</h3><p>您应该使用 AWS Auto Scaling 来管理跨多项服务的多个资源的扩展。借助 AWS Auto Scaling，您可以使用预定义的扩展策略为多个 EC2 Auto Scaling 组或其他资源定义动态扩展策略。</p><h2 id="二、Amazon-Elastic-Container-Registry"><a href="#二、Amazon-Elastic-Container-Registry" class="headerlink" title="二、Amazon Elastic Container Registry"></a>二、Amazon Elastic Container Registry</h2><h3 id="1、什么是-Amazon-Elastic-Container-Registry-Amazon-ECR-？"><a href="#1、什么是-Amazon-Elastic-Container-Registry-Amazon-ECR-？" class="headerlink" title="1、什么是 Amazon Elastic Container Registry (Amazon ECR)？"></a>1、什么是 Amazon Elastic Container Registry (Amazon ECR)？</h3><p>Amazon ECR 是完全托管的容器注册表，可让开发人员轻松地共享和部署容器镜像和构件。Amazon ECR 与 Amazon Elastic Container Service (Amazon ECS)、 Amazon Elastic Kubernetes Service (Amazon EKS) 和 AWS Lambda 集成，可简化您从开发到生产的工作流。Amazon ECR 使您无需操作自己的容器注册表，或使您不必为扩展底层基础设施而感到担心。Amazon ECR 将您的映像存储在高度可用、可扩展的基础架构中，使您能够为应用程序可靠部署容器。与 AWS Identity and Access Management (IAM) 的集成提供了对每个存储库的资源级控制，让您能够跨组织或与世界上任何人共享映像。</p><h3 id="2、使用场景-1"><a href="#2、使用场景-1" class="headerlink" title="2、使用场景"></a>2、使用场景</h3><p>Amazon ECR 使您无需操作和扩展增强容器注册表功能所需的基础设施。Amazon ECR 使用 Amazon Simple Storage Service (S3) 进行存储，可确保您的容器映像高度可用且可访问，允许您可靠地为应用程序部署新的容器。Amazon ECR 通过 HTTPS 传输您的容器映像，然后自动对静态映像进行加密。您可以通过配置策略来管理每个存储库的权限并限制对 IAM 用户、角色或其他 AWS 账户的访问。Amazon ECR 与 Amazon ECS、Amazon EKS、AWS Fargate、AWS Lambda 和 Docker CLI 集成，使您能够简化开发和生产工作流。您可以使用 Docker CLI 轻松将容器映像从开发计算机推送到 Amazon ECR，并且 Amazon 容器编排工具或计算可以直接将其取回进行生产部署。</p><h2 id="三、Amazon-Elastic-Container-Service"><a href="#三、Amazon-Elastic-Container-Service" class="headerlink" title="三、Amazon Elastic Container Service"></a>三、Amazon Elastic Container Service</h2><h3 id="1、什么是-Amazon-Elastic-Container-Service？"><a href="#1、什么是-Amazon-Elastic-Container-Service？" class="headerlink" title="1、什么是 Amazon Elastic Container Service？"></a>1、什么是 Amazon Elastic Container Service？</h3><p>Amazon Elastic Container Service (ECS) 是一项高度可扩展的高性能容器管理服务，支持 Docker 容器，并让您能够在托管的 Amazon Elastic Compute Cloud (Amazon EC2) 实例集群上轻松运行应用程序。</p><h3 id="2、使用场景-2"><a href="#2、使用场景-2" class="headerlink" title="2、使用场景"></a>2、使用场景</h3><p>使用 Amazon ECS，您将不再需要安装、运维、扩展自己的集群管理基础设施，Amazon ECS 让容器的使用更简单，您可以将其作为构建块用于您的应用程序。</p><p>Amazon ECS 集成有您熟悉的功能，包括 Elastic Load Balancing、EBS 卷、Amazon Virtual Private Cloud (VPC) 和 IAM。</p><h3 id="3、Amazon-ECS-与-AWS-Elastic-Beanstalk-有什么区别？"><a href="#3、Amazon-ECS-与-AWS-Elastic-Beanstalk-有什么区别？" class="headerlink" title="3、Amazon ECS 与 AWS Elastic Beanstalk 有什么区别？"></a>3、Amazon ECS 与 AWS Elastic Beanstalk 有什么区别？</h3><p>AWS Elastic Beanstalk 是一个应用程序管理平台，可以帮助客户轻松部署和扩展 Web 应用程序和服务。它将构建块（例如 EC2、Amazon RDS、Elastic Load Balancing、AWS Auto Scaling 和 Amazon CloudWatch）的预置、应用程序的部署、运行状况监控从用户身上分离出来，让用户可以集中精力编写代码。您只需指定要部署的容器映像、CPU 和内存要求、端口映射和容器链接即可。</p><p>简易选AWS Elastic Beanstalk，自定义应用程序架构精细化的控制则选Amazon ECS 。</p><h3 id="4、Amazon-ECS-与-AWS-Lambda-有什么区别？"><a href="#4、Amazon-ECS-与-AWS-Lambda-有什么区别？" class="headerlink" title="4、Amazon ECS 与 AWS Lambda 有什么区别？"></a>4、Amazon ECS 与 AWS Lambda 有什么区别？</h3><p>Amazon Container Service 是一项高度可扩展的 Docker 容器管理服务。</p><p>AWS Lambda 是一项事件驱动型任务计算服务，在响应数据更改、网站点击或来自其他 AWS 服务的消息等“事件”时运行您的代码，无需您管理任何计算基础设施。</p><h2 id="四、Amazon-Elastic-Compute-Cloud（Amazon-EC2）"><a href="#四、Amazon-Elastic-Compute-Cloud（Amazon-EC2）" class="headerlink" title="四、Amazon Elastic Compute Cloud（Amazon EC2）"></a>四、Amazon Elastic Compute Cloud（Amazon EC2）</h2><h3 id="1、什么是-Amazon-Elastic-Compute-Cloud（Amazon-EC2）？"><a href="#1、什么是-Amazon-Elastic-Compute-Cloud（Amazon-EC2）？" class="headerlink" title="1、什么是 Amazon Elastic Compute Cloud（Amazon EC2）？"></a>1、什么是 Amazon Elastic Compute Cloud（Amazon EC2）？</h3><p>Amazon EC2 是一种 Web 服务，可以在云中提供可调整大小的计算容量。该服务旨在让开发人员能更轻松地进行 Web 级的计算。</p><h3 id="2、Amazon-EC2-可以用来做什么？"><a href="#2、Amazon-EC2-可以用来做什么？" class="headerlink" title="2、Amazon EC2 可以用来做什么？"></a>2、Amazon EC2 可以用来做什么？</h3><p>正如 Amazon Simple Storage Service（Amazon S3）实现云中的存储一样，Amazon EC2 可以实现云中的“计算”。  Amazon EC2 云服务器的 Web 云服务接口非常简单，您可以最小的阻力轻松获取容量，随之配置容量。使用该服务，您将能完全控制您的计算资源，并可在成熟的 Amazon 计算环境中运行。Amazon EC2 将获取并启动新服务器实例所需要的时间缩短至几分钟，这样一来，在您的计算要求发生变化时，您便可以快速扩展或缩减计算容量。Amazon EC2 按您实际使用的容量收费，改变了计算的成本结算方式。</p><h2 id="五、Amazon-EKS"><a href="#五、Amazon-EKS" class="headerlink" title="五、Amazon EKS"></a>五、Amazon EKS</h2><h3 id="1、什么是-Amazon-Elastic-Kubernetes-Service-Amazon-EKS-？"><a href="#1、什么是-Amazon-Elastic-Kubernetes-Service-Amazon-EKS-？" class="headerlink" title="1、什么是 Amazon Elastic Kubernetes Service (Amazon EKS)？"></a>1、什么是 Amazon Elastic Kubernetes Service (Amazon EKS)？</h3><p>Amazon EKS 是一项托管服务，借助该服务，您可以轻松在 AWS 上运行 Kubernetes，而无需安装和操作您自己的 Kubernetes 控制面板或工作线程节点。</p><h3 id="2、什么是-Kubernetes？"><a href="#2、什么是-Kubernetes？" class="headerlink" title="2、什么是 Kubernetes？"></a>2、什么是 Kubernetes？</h3><p>Kubernetes 是一款开源容器编排系统，您可以利用它大规模地部署和管理容器化应用程序。Kubernetes 会将容器安排到各个逻辑分组以便进行管理和查找，然后在 Amazon Elastic Compute Cloud (Amazon EC2) 实例集群上启动它们。使用 Kubernetes，您可以使用同一工具集在本地和云中运行容器化应用程序，包括微服务、批处理工作线程和平台即服务 (PaaS)。</p><h3 id="3、使用场景"><a href="#3、使用场景" class="headerlink" title="3、使用场景"></a>3、使用场景</h3><p>Amazon EKS 可跨多个 AWS 可用区 (AZ) 预置和扩展 Kubernetes 控制面板（包括应用程序编程接口 (API) 服务器和后端持久层），从而获得高可用性和容错能力。Amazon EKS 可自动检测和替换运行状况不佳的控制面板节点并修补控制面板。您可以使用 AWS Fargate 运行 EKS，前者提供适用于容器的无服务器计算。使用 Fargate，您无需预置和管理服务器，而且可以为每个应用程序指定资源并为其付费，并通过设计隔离应用程序来提高安全性。</p><p>Amazon EKS 可与许多 AWS 服务集成，为应用程序提供可扩展性和安全性。这些产品包括用于分配负载的 Elastic Load Balancing、用于身份验证的 AWS Identity and Access Management (IAM)、用于隔离的 Amazon Virtual Private Cloud (VPC) 和用于日志记录的 AWS CloudTrail。</p><h3 id="4、工作原理"><a href="#4、工作原理" class="headerlink" title="4、工作原理"></a>4、工作原理</h3><p>Amazon EKS 可为您预置（启动）和管理 Kubernetes 控制面板和工作线程节点。总体来说，Kubernetes 由两大组件构成：运行容器的工作线程节点群集和管理容器在集群上的启动时间和位置并监控容器状态的控制面板。</p><p>如果不使用 Amazon EKS，您需要自行运行 Kubernetes 控制面板和工作线程节点群集。使用 Amazon EKS，您可以在 EKS 控制台、命令行界面 (CLI) 或 API 中通过单个命令预置您的工作线程节点。AWS 在高度可用且安全的配置中处理 Kubernetes 控制面板的预置、扩展和管理。这消除了操作重担，让您能够专注于应用程序构建而非 AWS 基础设施管理。</p><h2 id="六、Amazon-Lightsail"><a href="#六、Amazon-Lightsail" class="headerlink" title="六、Amazon Lightsail"></a>六、Amazon Lightsail</h2><h3 id="1、什么是-Amazon-Lightsail？"><a href="#1、什么是-Amazon-Lightsail？" class="headerlink" title="1、什么是 Amazon Lightsail？"></a>1、什么是 Amazon Lightsail？</h3><p>Amazon Lightsail 提供虚拟专用服务器 (VPS) ，它是开发人员、小型企业、学生以及其他需要在云上构建和托管其应用程序的解决方案的用户开始使用 AWS 产品&#x2F;服务的最简单方式。Lightsail 为开发人员提供计算、存储以及网络容量和功能，让其能够在云中部署并管理网站和 Web 应用程序。Lightsail 可提供快速启动项目所需的一切要素，包括虚拟机、容器、数据库、CDN、负载均衡器、DNS 管理等，目前月度价格低廉。</p><h3 id="2、什么是虚拟专用服务器？"><a href="#2、什么是虚拟专用服务器？" class="headerlink" title="2、什么是虚拟专用服务器？"></a>2、什么是虚拟专用服务器？</h3><p>虚拟专用服务器也称为“实例”，允许用户在高度安全和可用的环境中运行网站和 Web 应用程序，同时保持成本效益。</p><h3 id="3、使用场景-1"><a href="#3、使用场景-1" class="headerlink" title="3、使用场景"></a>3、使用场景</h3><p>您可以在几个预配置的 VPS 计划中进行选择，其中包括轻松部署和管理应用程序的所需的一切内容。Lightsail 最适合那些需要几个虚拟专用服务器的项目和喜欢简单管理界面的用户。Lightsail 的常见使用案例包括运行网站、Web 应用程序、博客、电子商务网站、简单软件等。</p><h2 id="七、AWS-Batch"><a href="#七、AWS-Batch" class="headerlink" title="七、AWS Batch"></a>七、AWS Batch</h2><h3 id="1、什么是-AWS-Batch？"><a href="#1、什么是-AWS-Batch？" class="headerlink" title="1、什么是 AWS Batch？"></a>1、什么是 AWS Batch？</h3><p>AWS Batch 是一系列批处理管理功能，能够让开发人员、科学家和工程师轻松高效地在 AWS 上运行成千上万个批处理计算作业。AWS Batch 可根据提交的批处理作业的卷和特定资源需求动态预置最佳的计算资源（如 CPU 或内存优化计算资源）数量和类型。借助 AWS Batch，您无需安装和管理批处理计算软件或服务器集群，从而使您能够集中精力分析结果和解决问题。AWS Batch 使用 Amazon ECS、Amazon EKS 和 AWS Fargate 计划、安排和执行您的批处理计算工作负载，并可选择使用竞价型实例。</p><h3 id="2、使用场景-3"><a href="#2、使用场景-3" class="headerlink" title="2、使用场景"></a>2、使用场景</h3><p>如果您希望 AWS Batch 处理来自 ECS 基础设施的完全抽象化的计算预置时，则应在 Fargate 上运行作业。如果您需要访问特定的实例配置（特定的处理器、GPU 或架构）或非常大的工作负载，则应在 ECS 上运行作业。如果您选择 Kubernetes 作为您的容器编排技术，则可以使用与 EKS 的批处理集成来标准化您的批处理工作负载。</p><p>根据您的用例，目前，Fargate 作业在初始扩展工作时能够更快启动，因为无需等待 EC2 实例或容器组启动。但是，对于较大的工作负载，EKS 或 ECS 实例可能更快，因为 Batch 会重用实例和容器镜像来运行后续作业。</p><h2 id="八、AWS-Data-Exchange"><a href="#八、AWS-Data-Exchange" class="headerlink" title="八、AWS Data Exchange"></a>八、AWS Data Exchange</h2><h3 id="1、什么是AWS-Data-Exchange"><a href="#1、什么是AWS-Data-Exchange" class="headerlink" title="1、什么是AWS Data Exchange"></a>1、什么是AWS Data Exchange</h3><p>AWS Data Exchange 使 AWS 客户可以轻松安全地在 AWS 上交换和使用第三方数据。</p><p>AWS Data Exchange 拥有单一的全球产品目录，由任何受支持的 AWS 区域的提供商提供。无论您使用哪个区域，您都可以看到相同的目录。产品的基础资源（数据集、修订版、资产）是您以编程方式或通过特定 AWS 区域中的 AWS Data Exchange 控制台进行管理的区域资源。</p><h2 id="九、AWS-Elastic-Beanstalk"><a href="#九、AWS-Elastic-Beanstalk" class="headerlink" title="九、AWS Elastic Beanstalk"></a>九、AWS Elastic Beanstalk</h2><h3 id="1、什么是-AWS-Elastic-Beanstalk？"><a href="#1、什么是-AWS-Elastic-Beanstalk？" class="headerlink" title="1、什么是 AWS Elastic Beanstalk？"></a>1、什么是 AWS Elastic Beanstalk？</h3><p>AWS Elastic Beanstalk 让开发人员能够更加轻松地在 AWS 云中快速部署和管理应用程序。开发人员只需上传应用程序，Elastic Beanstalk 将自动处理容量预配置、负载均衡、Auto Scaling 和应用程序运行状况监控的部署细节。</p><h3 id="2、使用场景-4"><a href="#2、使用场景-4" class="headerlink" title="2、使用场景"></a>2、使用场景</h3><p>希望在 AWS 云中快速部署和管理应用程序的用户。无需熟悉云计算即可使用该服务。AWS Elastic Beanstalk 支持 Java、.NET、PHP、Node.js、Python、Ruby、Go 和 Docker Web 应用程序。</p><h2 id="十、AWS-Fargate"><a href="#十、AWS-Fargate" class="headerlink" title="十、AWS Fargate"></a>十、AWS Fargate</h2><h3 id="1、什么是-AWS-Fargate？"><a href="#1、什么是-AWS-Fargate？" class="headerlink" title="1、什么是 AWS Fargate？"></a>1、什么是 AWS Fargate？</h3><p>AWS Fargate 是一种适用于容器的无服务器计算引擎，可与 Amazon Elastic Container Service (ECS) 和 Amazon Elastic Kubernetes Service (EKS) 一起使用。通过 AWS Fargate 可以轻松专注于构建应用程序。使用 Fargate，您无需预置和管理服务器，而且可以为每个应用程序指定资源并为其付费，并通过设计隔离应用程序来提高安全性。</p><h3 id="2、使用场景-5"><a href="#2、使用场景-5" class="headerlink" title="2、使用场景"></a>2、使用场景</h3><p>借助 AWS Fargate，您能够专注于应用程序。您可规定应用程序的内容、联网、存储和扩展要求，无需实施预置、修补、集群容量管理或基础设施管理。</p><p>Amazon Elastic Container Service (ECS) 是一项高度可扩展的高性能容器管理服务，支持 Docker 容器，而 Amazon Elastic Kubernetes Service (EKS) 是一项完全托管的 Kubernetes 服务。ECS 和 EKS 均使用 Fargate 预置的容器以自动方式进行扩展、负载均衡并通过托管计划优化容器可用性，从而提供一种更简单的方式来构建和运行容器化应用程序。</p><p>选择 AWS Fargate 用于其隔离模型和安全性用途。如果您想启动容器而不预置或管理 EC2 实例，也应选择 Fargate。如果您需要加强对 EC2 实例的控制或支持更广泛的定制选项，那么请使用 ECS 或 EKS，不要使用 Fargate。将 EC2 用于 GPU 工作负载，目前 Fargate 对此不提供支持。</p><h2 id="十一、AWS-Lambda"><a href="#十一、AWS-Lambda" class="headerlink" title="十一、AWS Lambda"></a>十一、AWS Lambda</h2><h3 id="1、什么是-AWS-Lambda？"><a href="#1、什么是-AWS-Lambda？" class="headerlink" title="1、什么是 AWS Lambda？"></a>1、什么是 AWS Lambda？</h3><p>通过 AWS Lambda，无需预置或管理服务器即可运行代码。您只需按使用的计算时间付费 – 代码未运行时不产生费用。借助 Lambda，您几乎可以为任何类型的应用程序或后端服务运行代码，而且完全无需管理。只需上传您的代码，Lambda 会处理运行和扩展高可用性代码所需的一切工作。您可以将您的代码设置为自动从其他 AWS 服务触发，或者直接从任何 Web 或移动应用程序调用。</p><p>您在 AWS Lambda 上运行的代码以“Lambda 函数”上传。每个函数都有相关的配置信息，如其名称、描述、入口点和资源要求。代码必须以“无状态”样式编写，即应假设与底层计算基础设施无密切关系。本地文件系统访问、子过程和类似的项目可能不会超出请求的使用寿命，且任何持续状态都应存储在 Amazon S3、Amazon DynamoDB、Amazon EFS 或另一个可用 Internet 的存储服务中。Lambda 函数可包含库，甚至是本机库。</p><h3 id="2、什么是无服务器计算？"><a href="#2、什么是无服务器计算？" class="headerlink" title="2、什么是无服务器计算？"></a>2、什么是无服务器计算？</h3><p>无服务器计算让您可以在不考虑服务器的情况下构建并运行应用程序和服务。使用无服务器计算，您的应用程序仍在服务器上运行，但所有服务器管理工作均由 AWS 负责。无服务器计算的核心是 AWS Lambda，这项服务可使您无需预置或管理服务器即可运行代码。</p><h3 id="3、什么时候应该使用-AWS-Lambda？什么时候应该使用-Amazon-EC2？"><a href="#3、什么时候应该使用-AWS-Lambda？什么时候应该使用-Amazon-EC2？" class="headerlink" title="3、什么时候应该使用 AWS Lambda？什么时候应该使用 Amazon EC2？"></a>3、什么时候应该使用 AWS Lambda？什么时候应该使用 Amazon EC2？</h3><p>Amazon Web Services 提供一组计算服务以满足各种需求。</p><p>Amazon EC2 具有范围广泛的实例类型以及自定义操作系统、网络和安全设置以及整个软件堆栈的选项，可提供灵活性，从而让您能够将现有的应用程序轻松迁移到云中。使用 Amazon EC2，您将负责预置容量、监控服务器队列的运行状况和性能，并设计容错性和可扩展性。AWS Elastic Beanstalk 提供易用的服务，供您部署和扩展 Web 应用程序，您可以在其中保留对底层 EC2 实例的所有权和完整控制权。Amazon EC2 Container Service 是一项可扩展的管理服务，支持 Docker 容器，允许您轻松地在 Amazon EC2 实例的托管集群上运行分布式应用程序。</p><p>AWS Lambda 可用于依照对事件的响应轻松执行代码，如 Amazon S3 存储桶的更改、Amazon DynamoDB 表的更新或您的应用程序或设备生成的自定义事件。利用 Lambda，您不必预置您自己的实例；Lambda 会代您执行所有的运行和管理活动，包括容量预置、监控服务器队列运行状况、向底层计算资源应用安全补丁、部署您的代码、在前端运行 Web 服务以及监控和记录您的代码。AWS Lambda 为您的代码提供轻松的扩展和高可用性，从而无需您做额外努力。</p><h3 id="4、AWS-Lambda-函数的执行需要多长时间？"><a href="#4、AWS-Lambda-函数的执行需要多长时间？" class="headerlink" title="4、AWS Lambda 函数的执行需要多长时间？"></a>4、AWS Lambda 函数的执行需要多长时间？</h3><p>AWS Lambda 函数可以配置为每次执行最长运行 15 分钟。您可以将超时设置为 1 秒到 15 分钟之间的任何值。</p><h3 id="5、AWS-Lambda-是否支持版本控制？"><a href="#5、AWS-Lambda-是否支持版本控制？" class="headerlink" title="5、AWS Lambda 是否支持版本控制？"></a>5、AWS Lambda 是否支持版本控制？</h3><p>是。默认情况下，每个 AWS Lambda 函数拥有一个当前版本的代码。Lambda 函数客户端可调用特定的版本或获取最新的实施。</p><h3 id="6、上传代码后，AWS-Lambda-函数需要准备多久进行调用？"><a href="#6、上传代码后，AWS-Lambda-函数需要准备多久进行调用？" class="headerlink" title="6、上传代码后，AWS Lambda 函数需要准备多久进行调用？"></a>6、上传代码后，AWS Lambda 函数需要准备多久进行调用？</h3><p>部署时间根据代码大小的不同而不同，但 AWS Lambda 函数一般在上传后几秒钟内就能做好调用准备。</p><h3 id="7、为了满足我的分析需求，我应该如何在-AWS-Lambda-和-Amazon-Kinesis-Data-Analytics-之间进行选择？"><a href="#7、为了满足我的分析需求，我应该如何在-AWS-Lambda-和-Amazon-Kinesis-Data-Analytics-之间进行选择？" class="headerlink" title="7、为了满足我的分析需求，我应该如何在 AWS Lambda 和 Amazon Kinesis Data Analytics 之间进行选择？"></a>7、为了满足我的分析需求，我应该如何在 AWS Lambda 和 Amazon Kinesis Data Analytics 之间进行选择？</h3><p>AWS Lambda 允许您在短时间内（最多不超过 15 分钟），在单个逻辑分区（如一个分片）上对 Amazon Kinesis 或 Amazon DynamoDB Streams 中的数据执行基于时间的聚合（如计数、最大值、总和、平均值等）。这使您可以选择为基于事件的应用程序轻松设置简单的分析，而不会增加架构的复杂性，因为您的业务和分析逻辑可以位于同一个函数中。Lambda 允许根据事件时间戳，在最多 15 分钟的滚动窗口内进行聚合。Amazon Kinesis Data Analytics 允许您构建更复杂的分析应用程序，以支持灵活的处理选择和强大的容错能力，只需进行一次精确的处理，而不会重复，并且可以跨多个逻辑分区对整个数据流执行分析。借助 KDA，您可以使用事件时间或处理时间分析多种类型的聚合窗口（滚动窗口、交错窗口、滑动窗口、会话窗口）中的数据。</p><h3 id="8、如何使用-AWS-Lambda-函数响应-Amazon-CloudWatch-警报？"><a href="#8、如何使用-AWS-Lambda-函数响应-Amazon-CloudWatch-警报？" class="headerlink" title="8、如何使用 AWS Lambda 函数响应 Amazon CloudWatch 警报？"></a>8、如何使用 AWS Lambda 函数响应 Amazon CloudWatch 警报？</h3><p>首先应配置警报，使其发送 Amazon SNS 通知。然后从 AWS Lambda 控制台中选择一个 Lambda 函数并将其与 Amazon SNS 主题进行关联。请参阅 Amazon CloudWatch 开发人员指南，了解有关设置 Amazon CloudWatch 警报的更多信息。</p><h3 id="9、如何使用-AWS-Lambda-函数响应由-Amazon-Cognito-管理的用户或设备数据的变更？"><a href="#9、如何使用-AWS-Lambda-函数响应由-Amazon-Cognito-管理的用户或设备数据的变更？" class="headerlink" title="9、如何使用 AWS Lambda 函数响应由 Amazon Cognito 管理的用户或设备数据的变更？"></a>9、如何使用 AWS Lambda 函数响应由 Amazon Cognito 管理的用户或设备数据的变更？</h3><p>您可以从 AWS Lambda 控制台中选择一个函数，当与 Amazon Cognito 身份池关联的任何数据集进行同步时，触发这个函数。还可通过 AWS 软件开发工具包和 CLI 实现这一功能。请访问 Amazon Cognito，了解有关使用 Amazon Cognito 在用户设备间共享和同步数据的更多信息。</p><h3 id="10、如何通过-HTTPS-调用-AWS-Lambda-函数？"><a href="#10、如何通过-HTTPS-调用-AWS-Lambda-函数？" class="headerlink" title="10、如何通过 HTTPS 调用 AWS Lambda 函数？"></a>10、如何通过 HTTPS 调用 AWS Lambda 函数？</h3><p>通过使用 Amazon API Gateway 定义自定义的 RESTful API，您可以通过 HTTPS 调用 Lambda 函数。这为您的函数提供了终端节点，这些函数可以响应 GET、PUT 和 POST 等 REST 调用。</p><h2 id="十二、AWS-Outposts"><a href="#十二、AWS-Outposts" class="headerlink" title="十二、AWS Outposts"></a>十二、AWS Outposts</h2><h3 id="1、什么是AWS-Outposts？"><a href="#1、什么是AWS-Outposts？" class="headerlink" title="1、什么是AWS Outposts？"></a>1、什么是AWS Outposts？</h3><p>您可以使用 Outposts 机架来支持您具有低延迟或本地数据处理要求的应用程序。这些应用程序可能需要为终端用户应用程序生成近乎实时的响应，或者需要与其他本地系统通信或控制现场设备。它们可能包括在工厂车间中运行的工作负载，用于自动化生产操作、实时患者诊断或医学成像以及内容和流媒体处理。 您可以使用 Outposts 机架安全地存储和处理需要在本地或没有 AWS 区域的国家&#x2F;地区保留的客户数据。您可以在 Outposts 机架上运行数据密集型工作负载，并且如果将数据传输到 AWS 区域中既昂贵又浪费，而且想要更好的控制数据分析、备份和还原，则在本地处理数据。</p><h2 id="十三、AWS-Serverless-Application-Repository"><a href="#十三、AWS-Serverless-Application-Repository" class="headerlink" title="十三、AWS Serverless Application Repository"></a>十三、AWS Serverless Application Repository</h2><h3 id="1、什么是无服务器应用程序？"><a href="#1、什么是无服务器应用程序？" class="headerlink" title="1、什么是无服务器应用程序？"></a>1、什么是无服务器应用程序？</h3><p>无服务器应用程序无需预置、部署或管理服务器或其他基础设施。它们具有内置高可用性，并且可以连续自动扩展。您可以使用一种完全托管的 AWS 产品来构建和运行无服务器应用程序，包括用于计算的 AWS Lambda、用于 API 的 Amazon API Gateway 和用于数据库的 Amazon DynamoDB。</p><h3 id="2、什么是-AWS-Serverless-Application-Repository？"><a href="#2、什么是-AWS-Serverless-Application-Repository？" class="headerlink" title="2、什么是 AWS Serverless Application Repository？"></a>2、什么是 AWS Serverless Application Repository？</h3><p>AWS Serverless Application Repository 将 AWS 和其他 AWS 合作伙伴及开发人员发布的越来越多的无服务器应用程序集合在一起。借助 Serverless Application Repository，您可以轻松地为 Web 和移动后端、流式处理以及机器学习等常见使用案例部署应用程序，以便快速开始使用 AWS 无服务器平台。</p><h2 id="十四、VMware-Cloud-on-AWS"><a href="#十四、VMware-Cloud-on-AWS" class="headerlink" title="十四、VMware Cloud on AWS"></a>十四、VMware Cloud on AWS</h2><h3 id="1、什么是-VMware-Cloud-on-AWS？"><a href="#1、什么是-VMware-Cloud-on-AWS？" class="headerlink" title="1、什么是 VMware Cloud on AWS？"></a>1、什么是 VMware Cloud on AWS？</h3><p>VMware Cloud on AWS 是 AWS 为基于 vSphere 的所有工作负载提供的首选服务。VMware Cloud on AWS 在 AWS 云中提供 VMware 的企业级 SDDC 软件，并优化了对本地 AWS 服务的访问。 VMware Cloud on AWS 由 VMware Cloud Foundation 提供支持，集成了 VMware 的计算、存储和网络虚拟化产品（VMware vSphere、VMware vSAN 和 VMware NSX）以及 VMware vCenter Server 管理功能，并且经过了优化，可以在专用的弹性裸机 AWS 基础设施上运行。</p><h3 id="2、使用场景-6"><a href="#2、使用场景-6" class="headerlink" title="2、使用场景"></a>2、使用场景</h3><p>在所有基于 vSphere 的工作负载方面，AWS 是 VMware 的首选公共云合作伙伴。VMware Cloud on AWS 在基于 VMware 的数据中心与 AWS 云之间提供了一致且可互操作的基础设施和服务，从而最大限度地降低了管理不同环境的复杂性和相关风险。VMware Cloud on AWS 提供对 AWS 服务的本地访问，并提供创新技术，可提高企业应用程序在其生命周期内的价值。</p>]]></content>
    
    
    <categories>
      
      <category>考证之路</category>
      
      <category>AWS-SAP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AWS-SAP</tag>
      
      <tag>学习考证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板文件</title>
    <link href="/2023/09/10/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6/"/>
    <url>/2023/09/10/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>简单记录下网站的分录以及标签规划，便于撰写文档时加以参考。</p><h2 id="我的分类"><a href="#我的分类" class="headerlink" title="我的分类"></a>我的分类</h2><p>安全笔记： sec-notebook<br>考证之路： research-road<br>随想杂谈：talking<br>学习资源：learning</p><h2 id="我的标签"><a href="#我的标签" class="headerlink" title="我的标签"></a>我的标签</h2><p>安全笔记：web安全、二进制安全、漏洞分析、安全工具、渗透测试<br>考证之路： CISSP， 阿里云ACP<br>随想杂谈：海角天涯<br>学习资源：工具集合，资料整合, 杂七杂八</p><h2 id="字段说明"><a href="#字段说明" class="headerlink" title="字段说明"></a>字段说明</h2><ul><li>sticky： 置顶文章</li></ul><h2 id="常用markdown语法"><a href="#常用markdown语法" class="headerlink" title="常用markdown语法"></a>常用markdown语法</h2><h3 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h3><p>1.引用文字<br>Markdown 使用电子邮件样式&gt;字符进行块引用。它们表示为：</p><blockquote><p>这是一段引用的文字   </p></blockquote><p>2.任务列表<br>任务列表是标记为[ ]或[x]（未完成或完成）的项目的列表。例如：</p><ul><li><input disabled="" type="checkbox"> 这是一个任务列表项</li><li><input checked="" disabled="" type="checkbox"> 这是一个完成的列表项</li></ul><p>3.代码块<br>使用代码块很简单，输入’‘’之后在输入可选的语言标识符，然后按return键后输入代码，我们将通过语法高亮显示它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="span元素"><a href="#span元素" class="headerlink" title="span元素"></a>span元素</h3><p>1.链接<br>Markdown 支持两种类型的链接：内联和引用。在这两种样式中，链接文本都写在[方括号]内。</p><p>要创建内联链接，请在链接文本的结束方括号后立即使用一组常规括号。在常规括号内，输入URL地址，以及可选的用引号括起来的链接标题。例如：</p><p>This is <a href="http://example.com/" title="Title">an example</a> inline link.<br><a href="http://example.net/">This link</a> has no title attribute.</p><p>2.图片<br>图片和链接类似，只是需要添加一个额外的！字符，例如：<br><img src="/path/to/img.jpg" alt="替代文字"><br><img src="/path/to/img.jpg" alt="替代文字" title="可选标题"></p><p>3.斜体<br>一般使用星号用作斜体的强调。例如：<br><em>这是个重点</em></p><p>4.粗体<br>使用两个星号就是加粗，例如：<br><strong>这是个大重点</strong></p><p>5.段落中代码<br>段落中代码使用单个反引号进行包裹即可，例如：<br>请使用<code>print()</code>函数</p><p>6.删除线<br>删除线就是两个波浪号，例如：<br>~~这段文字被删除了</p><p>7.下划线<br>下划线就是&lt;u&gt;这个来实现，例如：<br><u>这是个下划线</u></p><p>8.表情符号<br>输入表情符号的语法是 :smile:</p><p>用户可以通过 ESC 按键触发表情符号的自动完成建议，或者在偏好设置面板里启用后自动触发表情符号。此外，还支持直接从 Edit -&gt; Emoji &amp; Symbols 菜单栏输入UTF8表情符号字符。</p><p>这些大概就够用了，待补充。</p>]]></content>
    
    
    <categories>
      
      <category>杂七杂八</category>
      
    </categories>
    
    
    <tags>
      
      <tag>说明文档</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>uoload-labs靶场文件上传漏洞通关之路（1）</title>
    <link href="/2023/09/10/%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0/uoload-labs%E9%9D%B6%E5%9C%BA%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E9%80%9A%E5%85%B3%E4%B9%8B%E8%B7%AF%EF%BC%881%EF%BC%89/"/>
    <url>/2023/09/10/%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0/uoload-labs%E9%9D%B6%E5%9C%BA%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E9%80%9A%E5%85%B3%E4%B9%8B%E8%B7%AF%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="靶场简介"><a href="#靶场简介" class="headerlink" title="靶场简介"></a>靶场简介</h2><p>upload-labs是一个使用php语言编写的，专门收集渗透测试和CTF中遇到的各种上传漏洞的靶场。靶场地址：<a href="https://github.com/c0ny1/upload-labs">https://github.com/c0ny1/upload-labs</a> 。<br>搭建环境为winodws 2003 + phpstudy2018（php5.2.17+apache） + 源码，只需将源码放置在www目录，在配置下站点域名管理，过程十分简单。唯一要注意的点就是80端口冲突时，可以改用其他空闲的端口，或者将iis服务（占用80端口）关闭掉。</p><h3 id="关于burpsuite光标对不准问题"><a href="#关于burpsuite光标对不准问题" class="headerlink" title="关于burpsuite光标对不准问题"></a>关于burpsuite光标对不准问题</h3><p>在使用burp抓包时遇到光标对不准的问题，想选中改掉文件名后缀结果光标一直在文字后面。经百度得知是分辨率的问题，我的拯救者是2k屏设置的是125%缩放，而burp并不支持就会导致文字错位。解决方案是直接把字体调大，我调到16pt。至于其他的该启动参数，设置javaw.exe支持高分辨率，我试了都不太行。</p><h2 id="第一关-前端js绕过"><a href="#第一关-前端js绕过" class="headerlink" title="第一关-前端js绕过"></a>第一关-前端js绕过</h2><p>第一关看源码可知网站通过checkfile函数，将上传的php后缀的文件进行了过滤，并且仅仅是在前端进行了过滤。前端JS绕过方式主要有三种：<br>1.修改html源码绕过。下载html源代码，将.php加入到允许上传的文件类型或者直接删除校验函数，然后在form元素中添加action参数指向要上传的地址即可。<br>2.在线修改js绕过。F12直接修改js，没跑通。<br>3.burp修改数据包绕过。该题仅有前端校验，那么我们上传个jpg，然后通过burp抓包修改为php即可。</p><h2 id="第二关-MIME"><a href="#第二关-MIME" class="headerlink" title="第二关-MIME"></a>第二关-MIME</h2><p>根据第二关提示可知这关是在服务端对数据包的MIME进行检查。<br>后端通过<code>$_FILES[&#39;userfile&#39;][&#39;type&#39;]</code>获取到的MIME信息进行文件格式的过滤,<code>$_FILES</code>指的是一个预定义的数组,用来获取通过POST方法上传文件的相关信息,包括文件的原名称、文件的MIME类型、已上传文件的大小等，其中<code>$_FILES[&#39;userfile&#39;][&#39;type&#39;]</code>获取到的是上传文件的 MIME 类型，常见的有image&#x2F;gif、image&#x2F;jpeg。</p><p>在本题中我们只需将上传的 php 脚本文件的 Content-Type 修改为 image&#x2F;jpeg 即可。后端实现过滤源代码如下：</p><p><code>if (($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/jpeg&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/png&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/gif&#39;))</code></p><h2 id="第三关"><a href="#第三关" class="headerlink" title="第三关-"></a>第三关-</h2>]]></content>
    
    
    <categories>
      
      <category>安全笔记</category>
      
      <category>靶场学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞靶场</tag>
      
      <tag>文件上传</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pikachu靶场实战之暴力破解（1）</title>
    <link href="/2023/09/10/%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0/pikachu%E9%9D%B6%E5%9C%BA%E5%AE%9E%E6%88%98%E4%B9%8B%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%EF%BC%881%EF%BC%89/"/>
    <url>/2023/09/10/%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0/pikachu%E9%9D%B6%E5%9C%BA%E5%AE%9E%E6%88%98%E4%B9%8B%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="靶场简介"><a href="#靶场简介" class="headerlink" title="靶场简介"></a>靶场简介</h2><p>Pikachu 是一个带有漏洞的Web应用系统，在这里包含了常见的 web 安全漏洞。 如果你是一个 Web 渗透测试学习人员且正发愁没有合适的靶场进行练习，那么 Pikachu 可能正合你意。以上是Pikachu漏洞平台的简介。</p><p>作为像我这种的安全新手，用 Pikachu 入门再好不过了，可供漏洞种类比较多，而且还免费，话不多说，直接开干。</p><h3 id="暴力破解概述"><a href="#暴力破解概述" class="headerlink" title="暴力破解概述"></a>暴力破解概述</h3><p>暴力破解即账号枚举, 攻击者使用自己的用户名和密码字典,对目的服务器进行一个一个尝试登陆,如果字典足够强大,最终就会猜解成功获取到用户名和密码。</p><h2 id="0x01-基于表单的暴力破解"><a href="#0x01-基于表单的暴力破解" class="headerlink" title="0x01 基于表单的暴力破解"></a>0x01 基于表单的暴力破解</h2><p>第一道题比较简单，前后端都没有验证码，输入错误的账号密码会返回一个<code>username or password is not exists</code>的提示。</p><p><img src="https://image.yeyusec.com/img/202208222324751.jpg" alt="baopo001"></p><p>那么，破解的思路就很清晰了，直接使用 burpsuite 的 intruder 进行账号密码暴力破解即可，字典的话，Github上这个字典库貌似很全，<a href="https://github.com/TheKingOfDuck/fuzzDicts">https://github.com/TheKingOfDuck/fuzzDicts</a> 。</p><p><img src="https://image.yeyusec.com/img/202208222342373.jpg" alt="baopo002"></p><p>抓包，将登录页面发送至 intruder ，并在 Positions 中将 username 和 password 设置为 payload，攻击方式选择 Cluster bomb。</p><p><img src="https://image.yeyusec.com/img/202208222342010.jpg" alt="baopo003"></p><blockquote><p>burpsuite 有四种 attack type（攻击方式），分别是</p><ol><li>Sinper（狙击手)：<br> 第一种攻击方式sinper主要是将bp截的包各个用$$符号标记的数据进行逐个遍历替换。</li><li>Battering ram（攻城槌）<br>这种攻击方式是将包内所有标记的数据进行同时替换再发出。</li><li>Pitchfork（干草叉）<br> 多参数同时爆破，但使用的是不同字典。</li><li>Cluster bomb（集束炸弹）<br> 多参数做笛卡尔乘积模式爆破。多个密码本对应多个位置，交叉组合，每一个密码本里的密码都对应于另一密码本所有密码。常用于爆破账号密码。</li></ol></blockquote><p><img src="https://image.yeyusec.com/img/202208222342731.jpg" alt="baopo004"></p><p>接着在 Payloads 模块将两个参数的字典导入，选择 Simple list 模式。</p><p><img src="https://image.yeyusec.com/img/202208222342183.jpg" alt="baopo005"></p><p>由于登录失败有明显的提示，可以将 <code>username or password is not exists</code> 加入到 Grep match 中对尝试登录的结果进行筛选。</p><p><img src="https://image.yeyusec.com/img/202208222342959.jpg" alt="baopo006"></p><p>因为导入的账号和密码字典都是 Top500， 根据 Cluste bomb 攻击模式的特性，尝试爆破次数高达 25 万次。我这小破电脑要跑很久了。下一关就直接用提示的账号密码了，不然要跑太久了。</p><p><img src="https://image.yeyusec.com/img/202208222347300.jpeg" alt="baopo007">最终筛选出 ’admin&#x2F;123456‘ ，’pikachu&#x2F;000000‘，’test&#x2F;abc123‘，这三组密码（ps: pikachu不在字典里，自己加的，哈哈)</p><h2 id="0x02-验证码绕过-on-server"><a href="#0x02-验证码绕过-on-server" class="headerlink" title="0x02 验证码绕过(on server)"></a>0x02 验证码绕过(on server)</h2><p>这关相比第一关多了个验证码，这也是实际操作中经常遇到的。</p><p><img src="https://image.yeyusec.com/img/202208222343739.jpg" alt="baopo2-001"></p><p>抓包可知再不改变验证码的情况下，用burp修改参数验证码一直有效，说明验证码没有跟随服务器更新，可以使用多次。那么接下来的操作步骤和第一关就差不多了。</p><p><img src="https://image.yeyusec.com/img/202208222343670.jpg" alt="baopo2-002"></p><p>设置参数。</p><p><img src="https://image.yeyusec.com/img/202208222343537.jpg" alt="baopo2-003"></p><p>直接攻击，然后就可以得到正确的账户密码了。</p><h2 id="0x03-验证码绕过-on-client"><a href="#0x03-验证码绕过-on-client" class="headerlink" title="0x03 验证码绕过(on client)"></a>0x03 验证码绕过(on client)</h2><p>这关从网页源码可知验证码是前端生成，并且在前端进行校验，这就很离谱。直接抓包，改包，不经过前端就ok了，和上一关操作步骤一模一样。</p><p><img src="https://image.yeyusec.com/img/202208222343776.jpg" alt="baopo3-001"></p><h2 id="0x04-token防爆破"><a href="#0x04-token防爆破" class="headerlink" title="0x04 token防爆破?"></a>0x04 token防爆破?</h2><p>这关的要点在于加入了 token，token 的作用主要是为了防止CSRF（跨站脚本攻击）。</p><p><img src="https://image.yeyusec.com/img/202208222344854.jpg" alt="baopo4-001"></p><p>返回的页面中会携带下一次需要用到的token，那么直接每次请求的时候将 token 取出，带入到下一次请求中即可。</p><p>这里我们的攻击模式需要选择为 Pitchfork。由于是一一对应的关系，字典还需要稍作调整。</p><p><img src="https://image.yeyusec.com/img/202208222344183.jpg" alt="baopo4-002"></p><p>注意由于是上一次的结果会带入到下一次尝试中，所有只能单线程运行，新版的burp是通过设置 resource pool来实现的。</p><p><img src="https://image.yeyusec.com/img/202208222344606.png" alt="baopo4-003"></p><p>另外，提取token使用的是 Grep Extract模块功能，直接选中token value值，即可直接生成提取表达式，贼方便！！！</p><p><img src="https://image.yeyusec.com/img/202208222344752.jpg" alt="baopo4-004"></p><p>最终也是成功获取账号密码，暴力破解关卡完结~~~</p>]]></content>
    
    
    <categories>
      
      <category>安全笔记</category>
      
      <category>靶场学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞靶场</tag>
      
      <tag>暴力破解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pikachu靶场实战之XSS漏洞（2）</title>
    <link href="/2023/09/10/%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0/pikachu%E9%9D%B6%E5%9C%BA%E5%AE%9E%E6%88%98%E4%B9%8BXSS%E6%BC%8F%E6%B4%9E%EF%BC%882%EF%BC%89/"/>
    <url>/2023/09/10/%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0/pikachu%E9%9D%B6%E5%9C%BA%E5%AE%9E%E6%88%98%E4%B9%8BXSS%E6%BC%8F%E6%B4%9E%EF%BC%882%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="XSS（跨站）漏洞概述"><a href="#XSS（跨站）漏洞概述" class="headerlink" title="XSS（跨站）漏洞概述"></a>XSS（跨站）漏洞概述</h2><p>Cross-Site Scripting 简称为“CSS”，为避免与前端叠成样式表的缩写”CSS”冲突，故又称XSS。一般XSS可以分为如下几种常见类型：</p><ol><li>反射型XSS;</li><li>存储型XSS;</li><li>DOM型XSS;<br>XSS漏洞的形成原因是由于程序对输入和输出没有进行合适的处理，使得精心构造的字符在前端被浏览器当做有效代码而执行。</li></ol><h2 id="0x01-反射型XSS漏洞（get-x2F-post）"><a href="#0x01-反射型XSS漏洞（get-x2F-post）" class="headerlink" title="0x01 反射型XSS漏洞（get&#x2F;post）"></a>0x01 反射型XSS漏洞（get&#x2F;post）</h2><blockquote><p>反射型XXS是一种非持久性的攻击，它指的是恶意攻击者往Web页面里插入恶意代码，当用户浏览该页时，嵌入其中Web里面的html代码会被执行，从而达到恶意攻击用户的目的。这里插入的恶意代码并没有保存在目标网站，需要引诱用户点击一个链接到目标网站的恶意链接来实施攻击。</p></blockquote><p><img src="https://image.yeyusec.com/img/202208250856586.jpg" alt="xss001"></p><p>第一题 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code>代码输入不进去，查看源代码可知是前端对字符数做了限制，<code>&lt;input class=&quot;xssr_in&quot; type=&quot;text&quot; maxlength=&quot;20&quot; name=&quot;message&quot;&gt;</code> 直接将maxlength改成100即可。</p><p><img src="https://image.yeyusec.com/img/202208250857364.jpg" alt="xss002"></p><p>成功弹出。</p><p><img src="https://image.yeyusec.com/img/202208250832424.png" alt="image-20220825083230381"></p><p>第二题是登录后，输入<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>也是能弹出，查看源代码。</p><p><img src="https://image.yeyusec.com/img/202208250839208.jpg" alt="xss003"></p><p>代码中就是将前端传入的参数原封不动的执行了，就存在xss漏洞。</p><h2 id="0x02-存储型xss"><a href="#0x02-存储型xss" class="headerlink" title="0x02 存储型xss"></a>0x02 存储型xss</h2><p>存储型xss 顾名思义就是恶意脚本会同正常信息一起被存到数据库或者文件中，等到用户在访问这个页面时就会成为受害者，这种漏洞常见于论坛、博客以及留言板。</p><p>直接上payload。</p><p><img src="https://image.yeyusec.com/img/202208250855627.jpg" alt="xss004"></p><p>重新加载下页面，依旧会弹出。也是说每个访问该页面的用户都会受到攻击。</p><p><img src="https://image.yeyusec.com/img/202208250855165.jpg" alt="xss005"></p><h2 id="0x03-DOM型xss"><a href="#0x03-DOM型xss" class="headerlink" title="0x03 DOM型xss"></a>0x03 DOM型xss</h2><p>DOM 型 XSS 其实是一种特殊类型的反射型 XSS，它是基于 DOM 文档对象模型的一种漏洞。<br>DOM 就是一个树状的模型，你可以编写 js 代码对树进行操作，比如获取节点的名称，增加一个元素等。DOM树长这样：</p><p><img src="https://image.yeyusec.com/img/202208260816087.jpg" alt="xss008"></p><p>再回到题目本身，可以发现输入框输入的字符为未经过处理而是直接拼接的，代码是<code>&quot;&lt;a href=&#39;&quot;+str+&quot;&#39;&gt;what do you see?&lt;/a&gt;&quot;</code>，那么直接闭合前面的a标签，然后插入恶意代码即可。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;#&#x27;</span> <span class="hljs-attr">onmouseover</span>=<span class="hljs-string">&quot;alert(&#x27;xss&#x27;)&quot;</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="https://image.yeyusec.com/img/202208260820291.jpg" alt="xss009"></p><blockquote><p>onmouseover事件：指鼠标移动都某个指点的HTML标签上，会出现什么效果。<br>onmouseout事件：指鼠标移出某个指点的HTML标签后，会出现什么效果。</p></blockquote><p>好，成功弹出。</p><h2 id="0x04-xss之盲打"><a href="#0x04-xss之盲打" class="headerlink" title="0x04 xss之盲打"></a>0x04 xss之盲打</h2><p>xss盲打在我的理解就是遇见输入框就先输入个弹窗脚本试试，或许就有什么惊喜。</p><p><img src="https://image.yeyusec.com/img/202208260836464.jpg" alt="xss010"></p><p>果不其然，在后台就有了新发现，弹窗成功。</p><p><img src="https://image.yeyusec.com/img/202208260837017.jpg" alt="xss011"></p><h2 id="0x05-xss之过滤"><a href="#0x05-xss之过滤" class="headerlink" title="0x05 xss之过滤"></a>0x05 xss之过滤</h2><p>废话不多说，直接上payload<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>，结果不出所料，直接被吞了。</p><p><img src="https://image.yeyusec.com/img/202208260842538.jpg" alt="xss012"></p><p>推测是做了过滤，那就变一种方式再来。</p><p><img src="https://image.yeyusec.com/img/202208260848371.jpg" alt="xss013"></p><p>看源码实际是利用正则将“&lt;script”替换为空。直接全部换成大写在弹出，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;<span class="hljs-title class_">SCRIpt</span>&gt;<span class="hljs-title class_">ALErt</span>(<span class="hljs-number">11</span>)&lt;<span class="hljs-title class_">SCRipt</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="0x06-xss之htmlspecialchars"><a href="#0x06-xss之htmlspecialchars" class="headerlink" title="0x06 xss之htmlspecialchars"></a>0x06 xss之htmlspecialchars</h2><p>查询资料可知，php的htmlspecialchars()函数是将预定义的字符转换成HTML实体，HTML实体是浏览器用来代替特殊的字符的一种代码。有时候需要在文档内容中这些字符，但是不想让它们作为HTML被处理，为此应该使用这些实体（比如将 <code>&lt; </code>小于号转换成<code>&amp;lt；</code>）。比如：</p><blockquote><p>预定义的字符是：</p><ul><li>&amp; （和号）成为 &amp;</li><li>“ （双引号）成为 “</li><li>‘ （单引号）成为 ‘</li><li>&lt; （小于）成为 &lt;</li><li>&gt; （大于）成为 &gt;</li></ul></blockquote><p>另外，函数常用的参数有：</p><blockquote><p>ENT_COMPAT - 默认。仅编码双引号。<br>ENT_QUOTES - 编码双引号和单引号。<br>ENT_NOQUOTES - 不编码任何引号。<br>可以看到，我们的<code>nihao&lt;&gt;h&quot;#&#39;hha</code>被转换成了<code>nihao&amp;lt;&amp;gt;h\&amp;quot;#\&#39;hha</code>，其中单引号并没有被转义，那么我们可以用单引号闭合href结合其他语句进行注入。</p></blockquote><p><img src="https://image.yeyusec.com/img/202209192205206.png" alt="xss001"></p><p><img src="https://image.yeyusec.com/img/202209192207817.png" alt="xss002"></p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme"><span class="hljs-symbol">&#x27;onclick=alert</span>(<span class="hljs-name">11</span>)&#x27;<br></code></pre></td></tr></table></figure><h2 id="0x07-xss之href输出"><a href="#0x07-xss之href输出" class="headerlink" title="0x07 xss之href输出"></a>0x07 xss之href输出</h2><p>这个直接看源码：<img src="https://image.yeyusec.com/img/202209192213882.png" alt="xss004"></p><p>源码中使用了htmlspecialchars的ENT_QUOTES，双引号及单引号以及左右尖括号均会被转义，可以使用javascript伪协议来执行js，payload如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">javascript</span>:<span class="hljs-title function_">alert</span>(<span class="hljs-number">11</span>)<br></code></pre></td></tr></table></figure><blockquote><p>伪协议不同于因特网上所真实存在的协议，如http:&#x2F;&#x2F;，https:&#x2F;&#x2F;，ftp:&#x2F;&#x2F;，</p><p>而是为关联应用程序而使用的.如:tencent:&#x2F;&#x2F;(关联QQ)，data:(用base64编码来在浏览器端输出二进制文件)，还有就是javascript:</p><p>我们可以在浏览地址栏里输入”javascript:alert(‘JS!’);”，点转到后会发现，实际上是把javascript:后面的代码当JavaScript来执行，并将结果值返回给当前页面。</p></blockquote><h2 id="0x08-xss之js输出"><a href="#0x08-xss之js输出" class="headerlink" title="0x08 xss之js输出"></a>0x08 xss之js输出</h2><p>这道题的特点在于我们的输入被带入到js中，对我们输入的数据进行判断再动态生成内容。那么我们注入的话，可以使用单引号以及script标签闭合掉前面的script，再插入自己的注入代码。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;&lt;/script&gt;&lt;script&gt;alert(11)&lt;/script&gt;</span><br></code></pre></td></tr></table></figure><p>成功弹出！！！</p><p><img src="https://image.yeyusec.com/img/202209192233198.png" alt="xss006"></p><h2 id="0x09-总结"><a href="#0x09-总结" class="headerlink" title="0x09 总结"></a>0x09 总结</h2><p>形成XSS漏洞的主要原因是程序对输入和输出的控制不够严格，导致“精心构造”的脚本输入后，在输到前端时被浏览器当作有效代码解析执行从而产生危害。</p><p>因此在XSS漏洞的防范上，一般会采用“对输入进行过滤”和“输出进行转义”的方式进行处理: 输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入; 输出转义：根据输出点的位置对输出到前端的内容进行适当转义;</p><h3 id="XSS常见Payload"><a href="#XSS常见Payload" class="headerlink" title="XSS常见Payload"></a>XSS常见Payload</h3><blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;xss&quot;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">javascript:alert(111)</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">alert(</span>&#x27;<span class="hljs-attr">XSS</span>&#x27;)&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">x</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">alert(1)</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;xss&#x27;)&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><p>其他可参考： <a href="https://www.cnblogs.com/xuehen/p/4814237.html">https://www.cnblogs.com/xuehen/p/4814237.html</a></p>]]></content>
    
    
    <categories>
      
      <category>安全笔记</category>
      
      <category>靶场学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞靶场</tag>
      
      <tag>xss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pikachu靶场实战之SQL注入漏洞（4）</title>
    <link href="/2023/09/10/%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0/pikachu%E9%9D%B6%E5%9C%BA%E5%AE%9E%E6%88%98%E4%B9%8BSQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E(4)/"/>
    <url>/2023/09/10/%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0/pikachu%E9%9D%B6%E5%9C%BA%E5%AE%9E%E6%88%98%E4%B9%8BSQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E(4)/</url>
    
    <content type="html"><![CDATA[<h2 id="SQL漏洞概述"><a href="#SQL漏洞概述" class="headerlink" title="SQL漏洞概述"></a>SQL漏洞概述</h2><blockquote><p>SQL注入是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。</p></blockquote><p>常见的SQL注入根据注入方式可分为：</p><ul><li>盲注 </li><li>Error 报错注入</li><li>Time 时间盲住</li><li>Union 注入</li><li>内联查询注入</li><li>拼接（堆）查询注入</li></ul><h3 id="1-漏洞产生的原因"><a href="#1-漏洞产生的原因" class="headerlink" title="1.漏洞产生的原因"></a>1.漏洞产生的原因</h3><p>SQL注入漏洞主要形成的原因是在数据交互中，前端的数据传入到后台处理时，没有做严格的判断，导致其传入的“数据”拼接到SQL语句中后，被当作SQL语句的一部分执行。 从而导致数据库受损（被脱裤、被删除、甚至整个服务器权限沦陷）。</p><h3 id="2-如何检测SQL注入的存在"><a href="#2-如何检测SQL注入的存在" class="headerlink" title="2.如何检测SQL注入的存在"></a>2.如何检测SQL注入的存在</h3><p>因为SQL注入常发生于用户和服务交互处（增删改查操作）,AJAX,API接口等等,可以重点检测这些地方有无SQL注入漏洞。</p><p>白盒测试：<br>1） 关键词匹配，找到SQL语句后看调用方式，变量值得传递以及是否有安全校验；<br>2）框架和代码结构查看，看代码对请求进行路由和分发的方式，路由分发方式的设计和实现是否存在隐患；<br>3）了解业务实现的方式以及设计的思路。</p><p>黑盒测试：<br>构建特殊的SQL注入语句在用户的输入点进行手工注入，或者直接用自动化注入工具如sqlmap。</p><h3 id="3-SQL注入的利用条件，影响以及危害"><a href="#3-SQL注入的利用条件，影响以及危害" class="headerlink" title="3.SQL注入的利用条件，影响以及危害"></a>3.SQL注入的利用条件，影响以及危害</h3><p>利用条件比较低，危害较大，例如数据库被拖库,管理员和重要人员信息泄露,甚至还能通过SQL注入漏洞直接获取webshell或者执行命令导致服务器系统权限被获取等等。</p><h3 id="4-SQL注入如何防范以及修复"><a href="#4-SQL注入如何防范以及修复" class="headerlink" title="4.SQL注入如何防范以及修复"></a>4.SQL注入如何防范以及修复</h3><p>在构建代码时，一般会从如下几个方面的策略来防止SQL注入漏洞：<br>1.对传进SQL语句里面的变量进行过滤，不允许危险字符传入；<br>2.使用参数化（Parameterized Query 或 Parameterized Statement）；<br>3.还有就是,目前有很多ORM框架会自动使用参数化解决注入问题,但其也提供了”拼接”的方式,所以使用时需要慎重!<br>在日常的监控时，一般采用日志监控+WAF的形式（统一的filter），部署防SQL注入的系统等。</p><h2 id="0x01-数字型注入-post"><a href="#0x01-数字型注入-post" class="headerlink" title="0x01 数字型注入(post)"></a>0x01 数字型注入(post)</h2><p>sql手工注入常规的流程如下，具体的可参考这篇《sql注入——手工注入》 <a href="https://anchorety.github.io/2020/01/18/sql%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5/%EF%BC%9A">https://anchorety.github.io/2020/01/18/sql%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5/：</a> ，里面详细的说明了SQL手工注入的各个步骤：<br>1.注入点测试；<br>注入点测试主要分为是否存在sql注入检测与sql注入类型检测两个部分。<br>2.当前表列数测试；<br>3.测试当前表哪些列有回显；<br>4.查询数据库名称；</p><p><img src="https://image.yeyusec.com/img/202209301559746.jpg" alt="sql表"><br>5.数据库表名获取；<br>6.字段获取；<br>7.读取关键字段；</p><p>下面以数字型注入为例简单说明下以上的几个步骤。</p><h4 id="第一步是注入点测试："><a href="#第一步是注入点测试：" class="headerlink" title="第一步是注入点测试："></a>第一步是注入点测试：</h4><p><img src="https://image.yeyusec.com/img/202209301606935.jpg" alt="sqlpost"></p><p><img src="https://image.yeyusec.com/img/202209301607081.jpeg"></p><p>依旧是burp抓包，改包，传入个<code>id=2&#39;</code>看看，报错了,证明这里可能有SQL注入，数字型注入的话可以通过<code>1 and 1=1</code>未报错，以及<code>1 and 1=2</code>来判断。</p><p><img src="https://image.yeyusec.com/img/202209301610136.jpg" alt="sql001"><br>页面运行正常，继续下一步。</p><p><img src="https://image.yeyusec.com/img/202209301610852.jpg" alt="sql002"></p><p>页面报错，很明显，这是个数字型注入。</p><blockquote><p>如果当前注入点类型为数字型，</p><ul><li><p>当输入 and 1&#x3D;1时，后台执行 Sql 语句：select * from &lt;表名&gt; where id &#x3D; x and 1&#x3D;1,没有语法错误且逻辑判断为正确，所以返回正常。</p></li><li><p>当输入 and 1&#x3D;2时，后台执行 Sql 语句：select * from &lt;表名&gt; where id &#x3D; x and 1&#x3D;2,没有语法错误但是逻辑判断为假，所以返回错误。</p></li></ul><p>而如果该注入点类型为字符型，</p><ul><li>当输入and 1&#x3D;1和 and 1&#x3D;2时，后台执行sql语句：select * from &lt;表名&gt; where id&#x3D;’x and 1&#x3D;1’和 select * from &lt;表名&gt; where id&#x3D;’x and 1&#x3D;1,将and语句作为字符进行id匹配，应该都没有查询结果，与事实不符因此该注入点为数字型注入点。</li></ul></blockquote><h4 id="第二步是当前表列数测试："><a href="#第二步是当前表列数测试：" class="headerlink" title="第二步是当前表列数测试："></a>第二步是当前表列数测试：</h4><p>注入的语句是<code>id=1 order by 1</code>，从1依次往后，直到出现运行错误。到3就报错了，说明只有两列。</p><p><img src="https://image.yeyusec.com/img/202209301616650.jpg" alt="sql003"></p><h4 id="第三步是测试当前表哪些列有回显；"><a href="#第三步是测试当前表哪些列有回显；" class="headerlink" title="第三步是测试当前表哪些列有回显；"></a>第三步是测试当前表哪些列有回显；</h4><p>测试的语句是<code>id=1 union select 1,2</code>,上面测试有几列就写到几列，通过回显可以看到这两列都能回显。</p><p><img src="https://image.yeyusec.com/img/202209301621534.jpg" alt="sqlunion"></p><h4 id="第四步是查询数据库名称；"><a href="#第四步是查询数据库名称；" class="headerlink" title="第四步是查询数据库名称；"></a>第四步是查询数据库名称；</h4><p>既然已经知道了显示位，那么将常用的函数代入查询即可。查询语句是<code>id=1 union select database(),user()</code>，可以看到数据库名称是 pikachu 。</p><p><img src="https://image.yeyusec.com/img/202209301638892.jpg" alt="sql004"></p><h4 id="第五步是数据库表名获取："><a href="#第五步是数据库表名获取：" class="headerlink" title="第五步是数据库表名获取："></a>第五步是数据库表名获取：</h4><h2 id="0x02-CSRF（post类型）"><a href="#0x02-CSRF（post类型）" class="headerlink" title="0x02 CSRF（post类型）"></a>0x02 CSRF（post类型）</h2><p>post请求不同于get，它将要修改的信息都放在请求体中，我们就没法通过伪造URL的方式来进行攻击。</p><p><img src="https://image.yeyusec.com/img/202209210016883.png"></p><p>那么，常用的攻击手法就是搭建一个有表单提交功能的服务器，然后诱导用户去点击。</p><p>用户服务器是：192.168.0.106</p><p>攻击服务器是：192.168.0.121</p><p>攻击服务器的页面源码如图，post.html.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;html&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml">                                                                                                       <span class="hljs-comment">&lt;!-- 这个script是用来自动提交表单的 --&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        window.onload = function() &#123;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        document.getElementById(&quot;submit&quot;).click();</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        &#125;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">    </span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>              <br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://192.168.0.106/pikachu/vul/csrf/csrfpost/csrf_post_edit.php&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span>&gt;</span>    </span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;girl&quot;</span> /&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;phonenum&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;12345678922&quot;</span> /&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;add&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;usa&quot;</span> /&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;xiannv@pikachu.com&quot;</span> /&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;submit&quot;</span> /&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit request&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display:none&quot;</span>/&gt;</span>                    <span class="hljs-comment">&lt;!-- style设置为display:none起到隐藏submit按钮的作用 --&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br>&lt;/html&gt; <br></code></pre></td></tr></table></figure><p>只要诱导用户点击<code>http://192.168.0.121/post.html</code>这个链接即可。</p><h2 id="0x03-CSRF-token"><a href="#0x03-CSRF-token" class="headerlink" title="0x03 CSRF token"></a>0x03 CSRF token</h2><p>继续登录抓包，发现这次的请求参数里面带上了token。</p><p><img src="https://image.yeyusec.com/img/202209210908089.jpg" alt="csrf004"></p><p>token的话，指的是每次请求，都增加一个随机码（需要够随机，不容易被伪造），后台每次对这个随机码进行验证。这个随机码就是Token。</p><p>我们查看修改页面的源码就会服务器返回的修改的源码发现有一个隐藏的属性token。</p><p><img src="https://image.yeyusec.com/img/202209210916486.jpg" alt="csrf005"></p><p>而在token_get_edit文件中，我们也能看到，修改后服务端会自动生成token。</p><p><img src="https://image.yeyusec.com/img/202209210919822.jpg" alt="csrf006"></p><p>按照前面csrf get的方法，攻击者会伪造一个GET URL去让用户点击。但用户正常提供GET请求时，会把服务器返回的token填入和提交，而攻击者伪造URL时除非前期抓包获取到这个返回的token，否则他是不会知道这个token的。所以攻击者无法构造GET URL。同理，对于POST方法也是一样。</p><p>对于CSRF漏洞来说，token是个很好的防御手段。</p><p>当然对于这关来说，我们可以用到burp的一个插件“CSRF Token Tracker”来过关，直接Extender里面搜索安装即可。</p><p>在CSRF Token Tracker页面做好基础的配置，包括host以及name。</p><p><img src="https://image.yeyusec.com/img/202209211956759.jpg" alt="csrf009"></p><p>接着抓包，然后发送到Repeater,修改里面的信息都为1再发送，发现没有修改成功，木有关系，点击“Follow Redirection”即可。</p><p><img src="https://image.yeyusec.com/img/202209212012751.jpg" alt="csrf007"></p><p>再看看网页端。</p><p><img src="https://image.yeyusec.com/img/202209212012678.jpg" alt="csrf008"></p><h2 id="0x04-CSRF漏洞的防范"><a href="#0x04-CSRF漏洞的防范" class="headerlink" title="0x04 CSRF漏洞的防范"></a>0x04 CSRF漏洞的防范</h2><p>CSRF漏洞的防护可以从以下三个方面进行考虑：</p><ul><li><p>CSRF自动防御策略：同源检测（Origin 和 Referer 验证）。</p></li><li><p>CSRF主动防御措施：Token验证 或者 双重Cookie验证 以及配合Samesite Cookie。</p></li><li><p>保证页面的幂等性，后端接口不要在GET页面中做用户操作。</p></li></ul><p>不同的防御措施有利有弊，在实际的实践的，我们还是需要结合具体的业务来综合考虑，选取出最合适的最佳实践。</p><p>参考文档：</p><ol><li><a href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html">https://tech.meituan.com/2018/10/11/fe-security-csrf.html</a>  前端安全系列（二）：如何防止CSRF攻击？</li><li><a href="https://www.cnblogs.com/dogecheng/p/11583412.html">https://www.cnblogs.com/dogecheng/p/11583412.html</a>  Pikachu漏洞练习平台实验</li></ol>]]></content>
    
    
    <categories>
      
      <category>安全笔记</category>
      
      <category>靶场学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞靶场</tag>
      
      <tag>SQL注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pikachu靶场实战之CSRF漏洞（3）</title>
    <link href="/2023/09/10/%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0/pikachu%E9%9D%B6%E5%9C%BA%E5%AE%9E%E6%88%98%E4%B9%8BCSRF%E6%BC%8F%E6%B4%9E(3)/"/>
    <url>/2023/09/10/%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0/pikachu%E9%9D%B6%E5%9C%BA%E5%AE%9E%E6%88%98%E4%B9%8BCSRF%E6%BC%8F%E6%B4%9E(3)/</url>
    
    <content type="html"><![CDATA[<h2 id="CSRF（跨站请求伪造）漏洞概述"><a href="#CSRF（跨站请求伪造）漏洞概述" class="headerlink" title="CSRF（跨站请求伪造）漏洞概述"></a>CSRF（跨站请求伪造）漏洞概述</h2><p>Cross-site request forgery 简称为“CSRF”，在CSRF的攻击场景中攻击者会伪造一个请求（这个请求一般是一个链接），然后欺骗目标用户进行点击，用户一旦点击了这个请求，整个攻击就完成了。<br>CSRF与XSS的区别：CSRF是借用户的权限完成攻击，攻击者并没有拿到用户的权限，而XSS是直接盗取到了用户的权限，然后实施破坏。</p><h3 id="1-漏洞场景"><a href="#1-漏洞场景" class="headerlink" title="1.漏洞场景"></a>1.漏洞场景</h3><p>小黑想要修改大白在购物网站 <code>www.xx.com</code>上填写的会员地址。<br>先看下大白是如何修改自己的密码的：<br>登录—修改会员信息，提交请求—修改成功。<br>所以小黑想要修改大白的信息，他需要拥有：1，登录权限 2，修改个人信息的请求。<br>但是大白又不会把自己xxx网站的账号密码告诉小黑，那小黑怎么办？<br>于是他自己跑到<code>www.xx.com</code>上注册了一个自己的账号，然后修改了一下自己的个人信息（比如：E-mail地址），他发现修改的请求是：<br><code>http://www.xxx.com/edit.php?email=xiaohei@88.com&amp;Change=Change</code><br>于是，他实施了这样一个操作：把这个链接伪装一下，在小白登录xxx网站后，欺骗他进行点击，小白点击这个链接后，个人信息就被修改了,小黑就完成了攻击目的。</p><h3 id="2-CSRF的攻击条件"><a href="#2-CSRF的攻击条件" class="headerlink" title="2.CSRF的攻击条件"></a>2.CSRF的攻击条件</h3><p>（1）目标网站对关键信息的操作（增删改）是否容易被伪造。</p><p>（2）登录态，如果用户不是登录状态，即使点击了伪造的请求也没用。</p><h3 id="3-CSRF和xss的区别"><a href="#3-CSRF和xss的区别" class="headerlink" title="3.CSRF和xss的区别"></a>3.CSRF和xss的区别</h3><p>CSRF是借用户的权限完成攻击，攻击者并没有拿到用户的权限，而XSS是直接盗取到了用户的权限，然后实施破坏。也就是说如果目标站点有xss漏洞，则攻击者可以欺骗用户访问有xss脚本的页面（盗取cookie），然后攻击者可以拿到用户的权限直接登录自己修改。</p><h3 id="4-如何确认站点有没有CSRF漏洞"><a href="#4-如何确认站点有没有CSRF漏洞" class="headerlink" title="4.如何确认站点有没有CSRF漏洞"></a>4.如何确认站点有没有CSRF漏洞</h3><p>关键在于对目标站点有增删改查的地方进行查看，看请求是否容易被伪造。</p><p>手工的话：</p><blockquote><p>检测CSRF漏洞是一项比较繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。</p></blockquote><p>工具检测,常用工具有burp，CSRFTester：</p><blockquote><p>以CSRFTester工具为例，CSRF漏洞检测工具的测试原理如下：使用CSRFTester进行测试时，首先需要抓取我们在浏览器中访问过的所有链接以及所有的表单等信息，然后通过在CSRFTester中修改相应的表单等信息，重新提交，这相当于一次伪造客户端请求。如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF漏洞，当然此款工具也可以被用来进行CSRF攻击。</p></blockquote><h2 id="0x01-CSRF（get类型）"><a href="#0x01-CSRF（get类型）" class="headerlink" title="0x01 CSRF（get类型）"></a>0x01 CSRF（get类型）</h2><p>直接用burp抓包，发现该网站更新用户信息使用的是get请求，那么如果我们将请求复制下来，将里面要修改的信息替换掉诱导用户去点击，即可完成CSRF攻击。</p><p><img src="https://image.yeyusec.com/img/202209200838082.jpg" alt="csrf001"></p><p>比如原来的用户性别为boy，那么我们可以构造如下的链接：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.106</span>:<span class="hljs-number">8097</span>/vul/csrf/csrfget/csrf_get_edit.<span class="hljs-property">php</span>?sex=dabandan&amp;phonenum=<span class="hljs-number">18626545453</span>&amp;add=zhejiang&amp;email=vince%40pikachu.<span class="hljs-property">com</span>&amp;submit=submit <br></code></pre></td></tr></table></figure><p>然后诱导用户去点击，那么用户的性别信息就变成了‘dabendan’。</p><p><img src="https://image.yeyusec.com/img/202209200841876.jpg" alt="csrf002"></p><h2 id="0x02-CSRF（post类型）"><a href="#0x02-CSRF（post类型）" class="headerlink" title="0x02 CSRF（post类型）"></a>0x02 CSRF（post类型）</h2><p>post请求不同于get，它将要修改的信息都放在请求体中，我们就没法通过伪造URL的方式来进行攻击。</p><p><img src="https://image.yeyusec.com/img/202209210016883.png"></p><p>那么，常用的攻击手法就是搭建一个有表单提交功能的服务器，然后诱导用户去点击。</p><p>用户服务器是：192.168.0.106</p><p>攻击服务器是：192.168.0.121</p><p>攻击服务器的页面源码如图，post.html.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;html&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml">                                                                                                       <span class="hljs-comment">&lt;!-- 这个script是用来自动提交表单的 --&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        window.onload = function() &#123;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        document.getElementById(&quot;submit&quot;).click();</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        &#125;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">    </span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>              <br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://192.168.0.106/pikachu/vul/csrf/csrfpost/csrf_post_edit.php&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span>&gt;</span>    </span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;girl&quot;</span> /&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;phonenum&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;12345678922&quot;</span> /&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;add&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;usa&quot;</span> /&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;xiannv@pikachu.com&quot;</span> /&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;submit&quot;</span> /&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit request&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display:none&quot;</span>/&gt;</span>                    <span class="hljs-comment">&lt;!-- style设置为display:none起到隐藏submit按钮的作用 --&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br>&lt;/html&gt; <br></code></pre></td></tr></table></figure><p>只要诱导用户点击<code>http://192.168.0.121/post.html</code>这个链接即可。</p><h2 id="0x03-CSRF-token"><a href="#0x03-CSRF-token" class="headerlink" title="0x03 CSRF token"></a>0x03 CSRF token</h2><p>继续登录抓包，发现这次的请求参数里面带上了token。</p><p><img src="https://image.yeyusec.com/img/202209210908089.jpg" alt="csrf004"></p><p>token的话，指的是每次请求，都增加一个随机码（需要够随机，不容易被伪造），后台每次对这个随机码进行验证。这个随机码就是Token。</p><p>我们查看修改页面的源码就会服务器返回的修改的源码发现有一个隐藏的属性token。</p><p><img src="https://image.yeyusec.com/img/202209210916486.jpg" alt="csrf005"></p><p>而在token_get_edit文件中，我们也能看到，修改后服务端会自动生成token。</p><p><img src="https://image.yeyusec.com/img/202209210919822.jpg" alt="csrf006"></p><p>按照前面csrf get的方法，攻击者会伪造一个GET URL去让用户点击。但用户正常提供GET请求时，会把服务器返回的token填入和提交，而攻击者伪造URL时除非前期抓包获取到这个返回的token，否则他是不会知道这个token的。所以攻击者无法构造GET URL。同理，对于POST方法也是一样。</p><p>对于CSRF漏洞来说，token是个很好的防御手段。</p><p>当然对于这关来说，我们可以用到burp的一个插件“CSRF Token Tracker”来过关，直接Extender里面搜索安装即可。</p><p>在CSRF Token Tracker页面做好基础的配置，包括host以及name。</p><p><img src="https://image.yeyusec.com/img/202209211956759.jpg" alt="csrf009"></p><p>接着抓包，然后发送到Repeater,修改里面的信息都为1再发送，发现没有修改成功，木有关系，点击“Follow Redirection”即可。</p><p><img src="https://image.yeyusec.com/img/202209212012751.jpg" alt="csrf007"></p><p>再看看网页端。</p><p><img src="https://image.yeyusec.com/img/202209212012678.jpg" alt="csrf008"></p><h2 id="0x04-CSRF漏洞的防范"><a href="#0x04-CSRF漏洞的防范" class="headerlink" title="0x04 CSRF漏洞的防范"></a>0x04 CSRF漏洞的防范</h2><p>CSRF漏洞的防护可以从以下三个方面进行考虑：</p><ul><li><p>CSRF自动防御策略：同源检测（Origin 和 Referer 验证）。</p></li><li><p>CSRF主动防御措施：Token验证 或者 双重Cookie验证 以及配合Samesite Cookie。</p></li><li><p>保证页面的幂等性，后端接口不要在GET页面中做用户操作。</p></li></ul><p>不同的防御措施有利有弊，在实际的实践的，我们还是需要结合具体的业务来综合考虑，选取出最合适的最佳实践。</p><p>参考文档：</p><ol><li><a href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html">https://tech.meituan.com/2018/10/11/fe-security-csrf.html</a>  前端安全系列（二）：如何防止CSRF攻击？</li><li><a href="https://www.cnblogs.com/dogecheng/p/11583412.html">https://www.cnblogs.com/dogecheng/p/11583412.html</a>  Pikachu漏洞练习平台实验</li></ol>]]></content>
    
    
    <categories>
      
      <category>安全笔记</category>
      
      <category>靶场学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞靶场</tag>
      
      <tag>CSRF</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
