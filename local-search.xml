<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>模板文件</title>
    <link href="/Grinlcm/2022/09/17/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6/"/>
    <url>/Grinlcm/2022/09/17/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>简单记录下网站的分录以及标签规划，便于撰写文档时加以参考。</p><h2 id="我的分类"><a href="#我的分类" class="headerlink" title="我的分类"></a>我的分类</h2><p>安全笔记： sec-notebook<br>考证之路： research-road<br>随想杂谈：talking<br>学习资源：learning</p><h2 id="我的标签"><a href="#我的标签" class="headerlink" title="我的标签"></a>我的标签</h2><p>安全笔记：web安全、二进制安全、漏洞分析、安全工具、渗透测试<br>考证之路： CISSP， 阿里云ACP<br>随想杂谈：海角天涯<br>学习资源：工具集合，资料整合, 杂七杂八</p><h2 id="字段说明"><a href="#字段说明" class="headerlink" title="字段说明"></a>字段说明</h2><ul><li>sticky： 置顶文章</li></ul><h2 id="常用markdown语法"><a href="#常用markdown语法" class="headerlink" title="常用markdown语法"></a>常用markdown语法</h2><h3 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h3><p>1.引用文字<br>Markdown 使用电子邮件样式&gt;字符进行块引用。它们表示为：</p><blockquote><p>这是一段引用的文字   </p></blockquote><p>2.任务列表<br>任务列表是标记为[ ]或[x]（未完成或完成）的项目的列表。例如：</p><ul><li><input disabled="" type="checkbox"> 这是一个任务列表项</li><li><input checked="" disabled="" type="checkbox"> 这是一个完成的列表项</li></ul><p>3.代码块<br>使用代码块很简单，输入’‘’之后在输入可选的语言标识符，然后按return键后输入代码，我们将通过语法高亮显示它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="span元素"><a href="#span元素" class="headerlink" title="span元素"></a>span元素</h3><p>1.链接<br>Markdown 支持两种类型的链接：内联和引用。在这两种样式中，链接文本都写在[方括号]内。</p><p>要创建内联链接，请在链接文本的结束方括号后立即使用一组常规括号。在常规括号内，输入URL地址，以及可选的用引号括起来的链接标题。例如：</p><p>This is <a href="http://example.com/" title="Title">an example</a> inline link.<br><a href="http://example.net/">This link</a> has no title attribute.</p><p>2.图片<br>图片和链接类似，只是需要添加一个额外的！字符，例如：<br><img src="/Grinlcm/path/to/img.jpg" alt="替代文字"><br><img src="/Grinlcm/path/to/img.jpg" alt="替代文字" title="可选标题"></p><p>3.斜体<br>一般使用星号用作斜体的强调。例如：<br><em>这是个重点</em></p><p>4.粗体<br>使用两个星号就是加粗，例如：<br><strong>这是个大重点</strong></p><p>5.段落中代码<br>段落中代码使用单个反引号进行包裹即可，例如：<br>请使用<code>print()</code>函数</p><p>6.删除线<br>删除线就是两个波浪号，例如：<br>~~这段文字被删除了</p><p>7.下划线<br>下划线就是&lt;u&gt;这个来实现，例如：<br><u>这是个下划线</u></p><p>8.表情符号<br>输入表情符号的语法是 :smile:</p><p>用户可以通过 ESC 按键触发表情符号的自动完成建议，或者在偏好设置面板里启用后自动触发表情符号。此外，还支持直接从 Edit -&gt; Emoji &amp; Symbols 菜单栏输入UTF8表情符号字符。</p><p>这些大概就够用了，待补充。</p>]]></content>
    
    
    <categories>
      
      <category>杂七杂八</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模板文件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pikachu靶场实战之XSS漏洞（2）</title>
    <link href="/Grinlcm/2022/08/25/%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0/pikachu%E9%9D%B6%E5%9C%BA%E5%AE%9E%E6%88%98%E4%B9%8BXSS%E6%BC%8F%E6%B4%9E%EF%BC%882%EF%BC%89/"/>
    <url>/Grinlcm/2022/08/25/%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0/pikachu%E9%9D%B6%E5%9C%BA%E5%AE%9E%E6%88%98%E4%B9%8BXSS%E6%BC%8F%E6%B4%9E%EF%BC%882%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="XSS（跨站）漏洞概述"><a href="#XSS（跨站）漏洞概述" class="headerlink" title="XSS（跨站）漏洞概述"></a>XSS（跨站）漏洞概述</h2><p>Cross-Site Scripting 简称为“CSS”，为避免与前端叠成样式表的缩写”CSS”冲突，故又称XSS。一般XSS可以分为如下几种常见类型：</p><ol><li>反射型XSS;</li><li>存储型XSS;</li><li>DOM型XSS;<br>XSS漏洞的形成原因是由于程序对输入和输出没有进行合适的处理，使得精心构造的字符在前端被浏览器当做有效代码而执行。</li></ol><h2 id="0x01-反射型XSS漏洞（get-x2F-post）"><a href="#0x01-反射型XSS漏洞（get-x2F-post）" class="headerlink" title="0x01 反射型XSS漏洞（get&#x2F;post）"></a>0x01 反射型XSS漏洞（get&#x2F;post）</h2><blockquote><p>反射型XXS是一种非持久性的攻击，它指的是恶意攻击者往Web页面里插入恶意代码，当用户浏览&gt;该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意攻击用户的目的。这里插入的恶&gt;意代码并没有保存在目标网站，需要引诱用户点击一个链接到目标网站的恶意链接来实施攻击。</p></blockquote><p><img src="https://image.yeyusec.com/img/202208250856586.jpg" alt="xss001"></p><p>第一题 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code>代码输入不进去，查看源代码可知是前端对字符数做了限制，<code>&lt;input class=&quot;xssr_in&quot; type=&quot;text&quot; maxlength=&quot;20&quot; name=&quot;message&quot;&gt;</code> 直接将maxlength改成100即可。</p><p><img src="https://image.yeyusec.com/img/202208250857364.jpg" alt="xss002"></p><p>成功弹出。</p><p><img src="https://image.yeyusec.com/img/202208250832424.png" alt="image-20220825083230381"></p><p>第二题是登录后，输入<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>也是能弹出，查看源代码。</p><p><img src="https://image.yeyusec.com/img/202208250839208.jpg" alt="xss003"></p><p>代码中就是将前端传入的参数原封不动的执行了，就存在xss漏洞。</p><h2 id="0x02-存储型xss"><a href="#0x02-存储型xss" class="headerlink" title="0x02 存储型xss"></a>0x02 存储型xss</h2><p>存储型xss 顾名思义就是恶意脚本会同正常信息一起被存到数据库或者文件中，等到用户在访问这个页面时就会成为受害者，这种漏洞常见于论坛、博客以及留言板。</p><p>直接上payload。</p><p><img src="https://image.yeyusec.com/img/202208250855627.jpg" alt="xss004"></p><p>重新加载下页面，依旧会弹出。也是说每个访问该页面的用户都会受到攻击。</p><p><img src="https://image.yeyusec.com/img/202208250855165.jpg" alt="xss005"></p><h2 id="0x03-DOM型xss"><a href="#0x03-DOM型xss" class="headerlink" title="0x03 DOM型xss"></a>0x03 DOM型xss</h2><p>DOM 型 XSS 其实是一种特殊类型的反射型 XSS，它是基于 DOM 文档对象模型的一种漏洞。<br>DOM 就是一个树状的模型，你可以编写 js 代码对树进行操作，比如获取节点的名称，增加一个元素等。DOM树长这样：</p><p><img src="https://image.yeyusec.com/img/202208260816087.jpg" alt="xss008"></p><p>再回到题目本身，可以发现输入框输入的字符为未经过处理而是直接拼接的，代码是<code>&quot;&lt;a href=&#39;&quot;+str+&quot;&#39;&gt;what do you see?&lt;/a&gt;&quot;</code>，那么直接闭合前面的a标签，然后插入恶意代码即可。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;#&#x27;</span> <span class="hljs-attr">onmouseover</span>=<span class="hljs-string">&quot;alert(&#x27;xss&#x27;)&quot;</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="https://image.yeyusec.com/img/202208260820291.jpg" alt="xss009"></p><blockquote><p>onmouseover事件：指鼠标移动都某个指点的HTML标签上，会出现什么效果。<br>onmouseout事件：指鼠标移出某个指点的HTML标签后，会出现什么效果。</p></blockquote><p>好，成功弹出。</p><h2 id="0x04-xss之盲打"><a href="#0x04-xss之盲打" class="headerlink" title="0x04 xss之盲打"></a>0x04 xss之盲打</h2><p>xss盲打在我的理解就是遇见输入框就先输入个弹窗脚本试试，或许就有什么惊喜。</p><p><img src="https://image.yeyusec.com/img/202208260836464.jpg" alt="xss010"></p><p>果不其然，在后台就有了新发现，弹窗成功。</p><p><img src="https://image.yeyusec.com/img/202208260837017.jpg" alt="xss011"></p><h2 id="0x05-xss之过滤"><a href="#0x05-xss之过滤" class="headerlink" title="0x05 xss之过滤"></a>0x05 xss之过滤</h2><p>废话不多说，直接上payload<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>，结果不出所料，直接被吞了。</p><p><img src="https://image.yeyusec.com/img/202208260842538.jpg" alt="xss012"></p><p>推测是做了过滤，那就变一种方式再来。</p><p><img src="https://image.yeyusec.com/img/202208260848371.jpg" alt="xss013"></p><p>看源码实际是利用正则将“&lt;script”替换为空。直接全部换成大写在弹出，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;<span class="hljs-variable constant_">SCRIPT</span>&gt;<span class="hljs-title function_">alert</span>(<span class="hljs-number">11</span>)&lt;<span class="hljs-variable constant_">SCRIPT</span>&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>安全笔记</category>
      
      <category>靶场学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞靶场,xss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pikachu靶场实战之暴力破解（1）</title>
    <link href="/Grinlcm/2022/08/18/%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0/pikachu%E9%9D%B6%E5%9C%BA%E5%AE%9E%E6%88%98%E4%B9%8B%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%EF%BC%881%EF%BC%89/"/>
    <url>/Grinlcm/2022/08/18/%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0/pikachu%E9%9D%B6%E5%9C%BA%E5%AE%9E%E6%88%98%E4%B9%8B%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="靶场简介"><a href="#靶场简介" class="headerlink" title="靶场简介"></a>靶场简介</h2><p>Pikachu 是一个带有漏洞的Web应用系统，在这里包含了常见的 web 安全漏洞。 如果你是一个 Web 渗透测试学习人员且正发愁没有合适的靶场进行练习，那么 Pikachu 可能正合你意。以上是Pikachu漏洞平台的简介。</p><p>作为像我这种的安全新手，用 Pikachu 入门再好不过了，可供漏洞种类比较多，而且还免费，话不多说，直接开干。</p><h3 id="暴力破解概述"><a href="#暴力破解概述" class="headerlink" title="暴力破解概述"></a>暴力破解概述</h3><p>暴力破解即账号枚举, 攻击者使用自己的用户名和密码字典,对目的服务器进行一个一个尝试登陆,如果字典足够强大,最终就会猜解成功获取到用户名和密码。</p><h2 id="0x01-基于表单的暴力破解"><a href="#0x01-基于表单的暴力破解" class="headerlink" title="0x01 基于表单的暴力破解"></a>0x01 基于表单的暴力破解</h2><p>第一道题比较简单，前后端都没有验证码，输入错误的账号密码会返回一个<code>username or password is not exists</code>的提示。</p><p><img src="https://image.yeyusec.com/img/202208222324751.jpg" alt="baopo001"></p><p>那么，破解的思路就很清晰了，直接使用 burpsuite 的 intruder 进行账号密码暴力破解即可，字典的话，Github上这个字典库貌似很全，<a href="https://github.com/TheKingOfDuck/fuzzDicts">https://github.com/TheKingOfDuck/fuzzDicts</a> 。</p><p><img src="https://image.yeyusec.com/img/202208222342373.jpg" alt="baopo002"></p><p>抓包，将登录页面发送至 intruder ，并在 Positions 中将 username 和 password 设置为 payload，攻击方式选择 Cluster bomb。</p><p><img src="https://image.yeyusec.com/img/202208222342010.jpg" alt="baopo003"></p><blockquote><p>burpsuite 有四种 attack type（攻击方式），分别是</p><ol><li>Sinper（狙击手)：<br> 第一种攻击方式sinper主要是将bp截的包各个用$$符号标记的数据进行逐个遍历替换。</li><li>Battering ram（攻城槌）<br>这种攻击方式是将包内所有标记的数据进行同时替换再发出。</li><li>Pitchfork（干草叉）<br> 多参数同时爆破，但使用的是不同字典。</li><li>Cluster bomb（集束炸弹）<br> 多参数做笛卡尔乘积模式爆破。多个密码本对应多个位置，交叉组合，每一个密码本里的密码都对应于另一密码本所有密码。常用于爆破账号密码。</li></ol></blockquote><p><img src="https://image.yeyusec.com/img/202208222342731.jpg" alt="baopo004"></p><p>接着在 Payloads 模块将两个参数的字典导入，选择 Simple list 模式。</p><p><img src="https://image.yeyusec.com/img/202208222342183.jpg" alt="baopo005"></p><p>由于登录失败有明显的提示，可以将 <code>username or password is not exists</code> 加入到 Grep match 中对尝试登录的结果进行筛选。</p><p><img src="https://image.yeyusec.com/img/202208222342959.jpg" alt="baopo006"></p><p>因为导入的账号和密码字典都是 Top500， 根据 Cluste bomb 攻击模式的特性，尝试爆破次数高达 25 万次。我这小破电脑要跑很久了。下一关就直接用提示的账号密码了，不然要跑太久了。</p><p><img src="https://image.yeyusec.com/img/202208222347300.jpeg" alt="baopo007">最终筛选出 ’admin&#x2F;123456‘ ，’pikachu&#x2F;000000‘，’test&#x2F;abc123‘，这三组密码（ps: pikachu不在字典里，自己加的，哈哈)</p><h2 id="0x02-验证码绕过-on-server"><a href="#0x02-验证码绕过-on-server" class="headerlink" title="0x02 验证码绕过(on server)"></a>0x02 验证码绕过(on server)</h2><p>这关相比第一关多了个验证码，这也是实际操作中经常遇到的。</p><p><img src="https://image.yeyusec.com/img/202208222343739.jpg" alt="baopo2-001"></p><p>抓包可知再不改变验证码的情况下，用burp修改参数验证码一直有效，说明验证码没有跟随服务器更新，可以使用多次。那么接下来的操作步骤和第一关就差不多了。</p><p><img src="https://image.yeyusec.com/img/202208222343670.jpg" alt="baopo2-002"></p><p>设置参数。</p><p><img src="https://image.yeyusec.com/img/202208222343537.jpg" alt="baopo2-003"></p><p>直接攻击，然后就可以得到正确的账户密码了。</p><h2 id="0x03-验证码绕过-on-client"><a href="#0x03-验证码绕过-on-client" class="headerlink" title="0x03 验证码绕过(on client)"></a>0x03 验证码绕过(on client)</h2><p>这关从网页源码可知验证码是前端生成，并且在前端进行校验，这就很离谱。直接抓包，改包，不经过前端就ok了，和上一关操作步骤一模一样。</p><p><img src="https://image.yeyusec.com/img/202208222343776.jpg" alt="baopo3-001"></p><h2 id="0x04-token防爆破"><a href="#0x04-token防爆破" class="headerlink" title="0x04 token防爆破?"></a>0x04 token防爆破?</h2><p>这关的要点在于加入了 token，token 的作用主要是为了防止CSRF（跨站脚本攻击）。</p><p><img src="https://image.yeyusec.com/img/202208222344854.jpg" alt="baopo4-001"></p><p>返回的页面中会携带下一次需要用到的token，那么直接每次请求的时候将 token 取出，带入到下一次请求中即可。</p><p>这里我们的攻击模式需要选择为 Pitchfork。由于是一一对应的关系，字典还需要稍作调整。</p><p><img src="https://image.yeyusec.com/img/202208222344183.jpg" alt="baopo4-002"></p><p>注意由于是上一次的结果会带入到下一次尝试中，所有只能单线程运行，新版的burp是通过设置 resource pool来实现的。</p><p><img src="https://image.yeyusec.com/img/202208222344606.png" alt="baopo4-003"></p><p>另外，提取token使用的是 Grep Extract模块功能，直接选中token value值，即可直接生成提取表达式，贼方便！！！</p><p><img src="https://image.yeyusec.com/img/202208222344752.jpg" alt="baopo4-004"></p><p>最终也是成功获取账号密码，暴力破解关卡完结~~~</p>]]></content>
    
    
    <categories>
      
      <category>安全笔记</category>
      
      <category>靶场学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞靶场,暴力破解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>uoload-labs靶场文件上传漏洞通关之路（1）</title>
    <link href="/Grinlcm/2022/08/04/%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0/uoload-labs%E9%9D%B6%E5%9C%BA%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E9%80%9A%E5%85%B3%E4%B9%8B%E8%B7%AF%EF%BC%881%EF%BC%89/"/>
    <url>/Grinlcm/2022/08/04/%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0/uoload-labs%E9%9D%B6%E5%9C%BA%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E9%80%9A%E5%85%B3%E4%B9%8B%E8%B7%AF%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="靶场简介"><a href="#靶场简介" class="headerlink" title="靶场简介"></a>靶场简介</h2><p>upload-labs是一个使用php语言编写的，专门收集渗透测试和CTF中遇到的各种上传漏洞的靶场。靶场地址：<a href="https://github.com/c0ny1/upload-labs">https://github.com/c0ny1/upload-labs</a> 。<br>搭建环境为winodws 2003 + phpstudy2018（php5.2.17+apache） + 源码，只需将源码放置在www目录，在配置下站点域名管理，过程十分简单。唯一要注意的点就是80端口冲突时，可以改用其他空闲的端口，或者将iis服务（占用80端口）关闭掉。</p><h3 id="关于burpsuite光标对不准问题"><a href="#关于burpsuite光标对不准问题" class="headerlink" title="关于burpsuite光标对不准问题"></a>关于burpsuite光标对不准问题</h3><p>在使用burp抓包时遇到光标对不准的问题，想选中改掉文件名后缀结果光标一直在文字后面。经百度得知是分辨率的问题，我的拯救者是2k屏设置的是125%缩放，而burp并不支持就会导致文字错位。解决方案是直接把字体调大，我调到16pt。至于其他的该启动参数，设置javaw.exe支持高分辨率，我试了都不太行。</p><h2 id="第一关-前端js绕过"><a href="#第一关-前端js绕过" class="headerlink" title="第一关-前端js绕过"></a>第一关-前端js绕过</h2><p>第一关看源码可知网站通过checkfile函数，将上传的php后缀的文件进行了过滤，并且仅仅是在前端进行了过滤。前端JS绕过方式主要有三种：<br>1.修改html源码绕过。下载html源代码，将.php加入到允许上传的文件类型或者直接删除校验函数，然后在form元素中添加action参数指向要上传的地址即可。<br>2.在线修改js绕过。F12直接修改js，没跑通。<br>3.burp修改数据包绕过。该题仅有前端校验，那么我们上传个jpg，然后通过burp抓包修改为php即可。</p><h2 id="第二关-MIME"><a href="#第二关-MIME" class="headerlink" title="第二关-MIME"></a>第二关-MIME</h2><p>根据第二关提示可知这关是在服务端对数据包的MIME进行检查。<br>后端通过<code>$_FILES[&#39;userfile&#39;][&#39;type&#39;]</code>获取到的MIME信息进行文件格式的过滤,<code>$_FILES</code>指的是一个预定义的数组,用来获取通过POST方法上传文件的相关信息,包括文件的原名称、文件的MIME类型、已上传文件的大小等，其中<code>$_FILES[&#39;userfile&#39;][&#39;type&#39;]</code>获取到的是上传文件的 MIME 类型，常见的有image&#x2F;gif、image&#x2F;jpeg。</p><p>在本题中我们只需将上传的 php 脚本文件的 Content-Type 修改为 image&#x2F;jpeg 即可。后端实现过滤源代码如下：</p><p><code>if (($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/jpeg&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/png&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/gif&#39;))</code></p><h2 id="第三关"><a href="#第三关" class="headerlink" title="第三关-"></a>第三关-</h2>]]></content>
    
    
    <categories>
      
      <category>安全笔记</category>
      
      <category>靶场学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞靶场,文件上传</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
