<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>pikachu靶场实战之CSRF漏洞（3）</title>
    <link href="/2022/09/21/%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0/pikachu%E9%9D%B6%E5%9C%BA%E5%AE%9E%E6%88%98%E4%B9%8BCSRF%E6%BC%8F%E6%B4%9E/"/>
    <url>/2022/09/21/%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0/pikachu%E9%9D%B6%E5%9C%BA%E5%AE%9E%E6%88%98%E4%B9%8BCSRF%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h2 id="CSRF（跨站请求伪造）漏洞概述"><a href="#CSRF（跨站请求伪造）漏洞概述" class="headerlink" title="CSRF（跨站请求伪造）漏洞概述"></a>CSRF（跨站请求伪造）漏洞概述</h2><p>Cross-site request forgery 简称为“CSRF”，在CSRF的攻击场景中攻击者会伪造一个请求（这个请求一般是一个链接），然后欺骗目标用户进行点击，用户一旦点击了这个请求，整个攻击就完成了。<br>CSRF与XSS的区别：CSRF是借用户的权限完成攻击，攻击者并没有拿到用户的权限，而XSS是直接盗取到了用户的权限，然后实施破坏。</p><h3 id="1-漏洞场景"><a href="#1-漏洞场景" class="headerlink" title="1.漏洞场景"></a>1.漏洞场景</h3><p>小黑想要修改大白在购物网站 <a href="http://www.xx.com上填写的会员地址./">www.xx.com上填写的会员地址。</a><br>先看下大白是如何修改自己的密码的：<br>登录—修改会员信息，提交请求—修改成功。<br>所以小黑想要修改大白的信息，他需要拥有：1，登录权限 2，修改个人信息的请求。<br>但是大白又不会把自己xxx网站的账号密码告诉小黑，那小黑怎么办？<br>于是他自己跑到<a href="http://www.xx.com上注册了一个自己的账号，然后修改了一下自己的个人信息（比如：E-mail地址），他发现修改的请求是：">www.xx.com上注册了一个自己的账号，然后修改了一下自己的个人信息（比如：E-mail地址），他发现修改的请求是：</a><br>【<a href="http://www.xxx.com/edit.php?email=xiaohei@88.com&amp;Change=Change%E3%80%91">http://www.xxx.com/edit.php?email=xiaohei@88.com&amp;Change=Change】</a><br>于是，他实施了这样一个操作：把这个链接伪装一下，在小白登录xxx网站后，欺骗他进行点击，小白点击这个链接后，个人信息就被修改了,小黑就完成了攻击目的。</p><h3 id="2-CSRF的攻击条件"><a href="#2-CSRF的攻击条件" class="headerlink" title="2.CSRF的攻击条件"></a>2.CSRF的攻击条件</h3><p>（1）目标网站对关键信息的操作（增删改）是否容易被伪造。</p><p>（2）登录态，如果用户不是登录状态，即使点击了伪造的请求也没用。</p><h3 id="3-CSRF和xss的区别"><a href="#3-CSRF和xss的区别" class="headerlink" title="3.CSRF和xss的区别"></a>3.CSRF和xss的区别</h3><p>CSRF是借用户的权限完成攻击，攻击者并没有拿到用户的权限，而XSS是直接盗取到了用户的权限，然后实施破坏。也就是说如果目标站点有xss漏洞，则攻击者可以欺骗用户访问有xss脚本的页面（盗取cookie），然后攻击者可以拿到用户的权限直接登录自己修改。</p><h3 id="4-如何确认站点有没有CSRF漏洞"><a href="#4-如何确认站点有没有CSRF漏洞" class="headerlink" title="4.如何确认站点有没有CSRF漏洞"></a>4.如何确认站点有没有CSRF漏洞</h3><p>关键在于对目标站点有增删改查的地方进行查看，看请求是否容易被伪造。</p><p>手工的话：</p><blockquote><p>检测CSRF漏洞是一项比较繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。</p></blockquote><p>工具检测,常用工具有burp，CSRFTester：</p><blockquote><p>以CSRFTester工具为例，CSRF漏洞检测工具的测试原理如下：使用CSRFTester进行测试时，首先需要抓取我们在浏览器中访问过的所有链接以及所有的表单等信息，然后通过在CSRFTester中修改相应的表单等信息，重新提交，这相当于一次伪造客户端请求。如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF漏洞，当然此款工具也可以被用来进行CSRF攻击。</p></blockquote><h2 id="0x01-CSRF（get类型）"><a href="#0x01-CSRF（get类型）" class="headerlink" title="0x01 CSRF（get类型）"></a>0x01 CSRF（get类型）</h2><p>直接用burp抓包，发现该网站更新用户信息使用的是get请求，那么如果我们将请求复制下来，将里面要修改的信息替换掉诱导用户去点击，即可完成CSRF攻击。</p><p><img src="https://image.yeyusec.com/img/202209200838082.jpg" alt="csrf001"></p><p>比如原来的用户性别为boy，那么我们可以构造如下的链接：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.106</span>:<span class="hljs-number">8097</span>/vul/csrf/csrfget/csrf_get_edit.<span class="hljs-property">php</span>?sex=dabandan&amp;phonenum=<span class="hljs-number">18626545453</span>&amp;add=zhejiang&amp;email=vince%40pikachu.<span class="hljs-property">com</span>&amp;submit=submit <br></code></pre></td></tr></table></figure><p>然后诱导用户去点击，那么用户的性别信息就变成了‘dabendan’。</p><p><img src="https://image.yeyusec.com/img/202209200841876.jpg" alt="csrf002"></p><h2 id="0x02-CSRF（post类型）"><a href="#0x02-CSRF（post类型）" class="headerlink" title="0x02 CSRF（post类型）"></a>0x02 CSRF（post类型）</h2><p>post请求不同于get，它将要修改的信息都放在请求体中，我们就没法通过伪造URL的方式来进行攻击。</p><p><img src="https://image.yeyusec.com/img/202209210016883.png"></p><p>那么，常用的攻击手法就是搭建一个有表单提交功能的服务器，然后诱导用户去点击。</p><p>用户服务器是：192.168.0.106</p><p>攻击服务器是：192.168.0.121</p><p>攻击服务器的页面源码如图，post.html.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;html&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml">                                                                                                       <span class="hljs-comment">&lt;!-- 这个script是用来自动提交表单的 --&gt;</span></span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        window.onload = function() &#123;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        document.getElementById(&quot;submit&quot;).click();</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">        &#125;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="language-xml">    </span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>              <br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://192.168.0.106/pikachu/vul/csrf/csrfpost/csrf_post_edit.php&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span>&gt;</span>    </span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;girl&quot;</span> /&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;phonenum&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;12345678922&quot;</span> /&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;add&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;usa&quot;</span> /&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;xiannv@pikachu.com&quot;</span> /&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;submit&quot;</span> /&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit request&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display:none&quot;</span>/&gt;</span>                    <span class="hljs-comment">&lt;!-- style设置为display:none起到隐藏submit按钮的作用 --&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br>&lt;/html&gt; <br></code></pre></td></tr></table></figure><p>只要诱导用户点击<a href="http://192.168.0.121/post.html%E8%BF%99%E4%B8%AA%E9%93%BE%E6%8E%A5%E5%8D%B3%E5%8F%AF%E3%80%82">http://192.168.0.121/post.html这个链接即可。</a></p><h2 id="0x03-CSRF-token"><a href="#0x03-CSRF-token" class="headerlink" title="0x03 CSRF token"></a>0x03 CSRF token</h2><p>继续登录抓包，发现这次的请求参数里面带上了token。</p><p><img src="https://image.yeyusec.com/img/202209210908089.jpg" alt="csrf004"></p><p>token的话，指的是每次请求，都增加一个随机码（需要够随机，不容易被伪造），后台每次对这个随机码进行验证。这个随机码就是Token。</p><p>我们查看修改页面的源码就会服务器返回的修改的源码发现有一个隐藏的属性token。</p><p><img src="https://image.yeyusec.com/img/202209210916486.jpg" alt="csrf005"></p><p>而在token_get_edit文件中，我们也能看到，修改后服务端会自动生成token。</p><p><img src="https://image.yeyusec.com/img/202209210919822.jpg" alt="csrf006"></p><p>按照前面csrf get的方法，攻击者会伪造一个GET URL去让用户点击。但用户正常提供GET请求时，会把服务器返回的token填入和提交，而攻击者伪造URL时除非前期抓包获取到这个返回的token，否则他是不会知道这个token的。所以攻击者无法构造GET URL。同理，对于POST方法也是一样。</p><p>对于CSRF漏洞来说，token是个很好的防御手段。</p><p>当然对于这关来说，我们可以用到burp的一个插件“CSRF Token Tracker”来过关，直接Extender里面搜索安装即可。</p><p>在CSRF Token Tracker页面做好基础的配置，包括host以及name。</p><p><img src="https://image.yeyusec.com/img/202209211956759.jpg" alt="csrf009"></p><p>接着抓包，然后发送到Repeater,修改里面的信息都为1再发送，发现没有修改成功，木有关系，点击“Follow Redirection”即可。</p><p><img src="https://image.yeyusec.com/img/202209212012751.jpg" alt="csrf007"></p><p>再看看网页端。</p><p><img src="https://image.yeyusec.com/img/202209212012678.jpg" alt="csrf008"></p><h2 id="0x04-CSRF漏洞的防范"><a href="#0x04-CSRF漏洞的防范" class="headerlink" title="0x04 CSRF漏洞的防范"></a>0x04 CSRF漏洞的防范</h2><p>CSRF漏洞的防护可以从以下三个方面进行考虑：</p><ul><li><p>CSRF自动防御策略：同源检测（Origin 和 Referer 验证）。</p></li><li><p>CSRF主动防御措施：Token验证 或者 双重Cookie验证 以及配合Samesite Cookie。</p></li><li><p>保证页面的幂等性，后端接口不要在GET页面中做用户操作。</p></li></ul><p>不同的防御措施有利有弊，在实际的实践的，我们还是需要结合具体的业务来综合考虑，选取出最合适的最佳实践。</p><p>参考文档：</p><ol><li><a href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html">https://tech.meituan.com/2018/10/11/fe-security-csrf.html</a> 前端安全系列（二）：如何防止CSRF攻击？</li><li><a href="https://www.cnblogs.com/dogecheng/p/11583412.html">https://www.cnblogs.com/dogecheng/p/11583412.html</a> Pikachu漏洞练习平台实验</li></ol>]]></content>
    
    
    <categories>
      
      <category>安全笔记</category>
      
      <category>靶场学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞靶场</tag>
      
      <tag>CSRF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板文件</title>
    <link href="/2022/09/17/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6/"/>
    <url>/2022/09/17/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>简单记录下网站的分录以及标签规划，便于撰写文档时加以参考。</p><h2 id="我的分类"><a href="#我的分类" class="headerlink" title="我的分类"></a>我的分类</h2><p>安全笔记： sec-notebook<br>考证之路： research-road<br>随想杂谈：talking<br>学习资源：learning</p><h2 id="我的标签"><a href="#我的标签" class="headerlink" title="我的标签"></a>我的标签</h2><p>安全笔记：web安全、二进制安全、漏洞分析、安全工具、渗透测试<br>考证之路： CISSP， 阿里云ACP<br>随想杂谈：海角天涯<br>学习资源：工具集合，资料整合, 杂七杂八</p><h2 id="字段说明"><a href="#字段说明" class="headerlink" title="字段说明"></a>字段说明</h2><ul><li>sticky： 置顶文章</li></ul><h2 id="常用markdown语法"><a href="#常用markdown语法" class="headerlink" title="常用markdown语法"></a>常用markdown语法</h2><h3 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h3><p>1.引用文字<br>Markdown 使用电子邮件样式&gt;字符进行块引用。它们表示为：</p><blockquote><p>这是一段引用的文字   </p></blockquote><p>2.任务列表<br>任务列表是标记为[ ]或[x]（未完成或完成）的项目的列表。例如：</p><ul><li><input disabled="" type="checkbox"> 这是一个任务列表项</li><li><input checked="" disabled="" type="checkbox"> 这是一个完成的列表项</li></ul><p>3.代码块<br>使用代码块很简单，输入’‘’之后在输入可选的语言标识符，然后按return键后输入代码，我们将通过语法高亮显示它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="span元素"><a href="#span元素" class="headerlink" title="span元素"></a>span元素</h3><p>1.链接<br>Markdown 支持两种类型的链接：内联和引用。在这两种样式中，链接文本都写在[方括号]内。</p><p>要创建内联链接，请在链接文本的结束方括号后立即使用一组常规括号。在常规括号内，输入URL地址，以及可选的用引号括起来的链接标题。例如：</p><p>This is <a href="http://example.com/" title="Title">an example</a> inline link.<br><a href="http://example.net/">This link</a> has no title attribute.</p><p>2.图片<br>图片和链接类似，只是需要添加一个额外的！字符，例如：<br><img src="/path/to/img.jpg" alt="替代文字"><br><img src="/path/to/img.jpg" alt="替代文字" title="可选标题"></p><p>3.斜体<br>一般使用星号用作斜体的强调。例如：<br><em>这是个重点</em></p><p>4.粗体<br>使用两个星号就是加粗，例如：<br><strong>这是个大重点</strong></p><p>5.段落中代码<br>段落中代码使用单个反引号进行包裹即可，例如：<br>请使用<code>print()</code>函数</p><p>6.删除线<br>删除线就是两个波浪号，例如：<br>~~这段文字被删除了</p><p>7.下划线<br>下划线就是&lt;u&gt;这个来实现，例如：<br><u>这是个下划线</u></p><p>8.表情符号<br>输入表情符号的语法是 :smile:</p><p>用户可以通过 ESC 按键触发表情符号的自动完成建议，或者在偏好设置面板里启用后自动触发表情符号。此外，还支持直接从 Edit -&gt; Emoji &amp; Symbols 菜单栏输入UTF8表情符号字符。</p><p>这些大概就够用了，待补充。</p>]]></content>
    
    
    <categories>
      
      <category>杂七杂八</category>
      
    </categories>
    
    
    <tags>
      
      <tag>说明文档</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pikachu靶场实战之XSS漏洞（2）</title>
    <link href="/2022/08/25/%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0/pikachu%E9%9D%B6%E5%9C%BA%E5%AE%9E%E6%88%98%E4%B9%8BXSS%E6%BC%8F%E6%B4%9E%EF%BC%882%EF%BC%89/"/>
    <url>/2022/08/25/%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0/pikachu%E9%9D%B6%E5%9C%BA%E5%AE%9E%E6%88%98%E4%B9%8BXSS%E6%BC%8F%E6%B4%9E%EF%BC%882%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="XSS（跨站）漏洞概述"><a href="#XSS（跨站）漏洞概述" class="headerlink" title="XSS（跨站）漏洞概述"></a>XSS（跨站）漏洞概述</h2><p>Cross-Site Scripting 简称为“CSS”，为避免与前端叠成样式表的缩写”CSS”冲突，故又称XSS。一般XSS可以分为如下几种常见类型：</p><ol><li>反射型XSS;</li><li>存储型XSS;</li><li>DOM型XSS;<br>XSS漏洞的形成原因是由于程序对输入和输出没有进行合适的处理，使得精心构造的字符在前端被浏览器当做有效代码而执行。</li></ol><h2 id="0x01-反射型XSS漏洞（get-x2F-post）"><a href="#0x01-反射型XSS漏洞（get-x2F-post）" class="headerlink" title="0x01 反射型XSS漏洞（get&#x2F;post）"></a>0x01 反射型XSS漏洞（get&#x2F;post）</h2><blockquote><p>反射型XXS是一种非持久性的攻击，它指的是恶意攻击者往Web页面里插入恶意代码，当用户浏览&gt;该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意攻击用户的目的。这里插入的恶&gt;意代码并没有保存在目标网站，需要引诱用户点击一个链接到目标网站的恶意链接来实施攻击。</p></blockquote><p><img src="https://image.yeyusec.com/img/202208250856586.jpg" alt="xss001"></p><p>第一题 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code>代码输入不进去，查看源代码可知是前端对字符数做了限制，<code>&lt;input class=&quot;xssr_in&quot; type=&quot;text&quot; maxlength=&quot;20&quot; name=&quot;message&quot;&gt;</code> 直接将maxlength改成100即可。</p><p><img src="https://image.yeyusec.com/img/202208250857364.jpg" alt="xss002"></p><p>成功弹出。</p><p><img src="https://image.yeyusec.com/img/202208250832424.png" alt="image-20220825083230381"></p><p>第二题是登录后，输入<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>也是能弹出，查看源代码。</p><p><img src="https://image.yeyusec.com/img/202208250839208.jpg" alt="xss003"></p><p>代码中就是将前端传入的参数原封不动的执行了，就存在xss漏洞。</p><h2 id="0x02-存储型xss"><a href="#0x02-存储型xss" class="headerlink" title="0x02 存储型xss"></a>0x02 存储型xss</h2><p>存储型xss 顾名思义就是恶意脚本会同正常信息一起被存到数据库或者文件中，等到用户在访问这个页面时就会成为受害者，这种漏洞常见于论坛、博客以及留言板。</p><p>直接上payload。</p><p><img src="https://image.yeyusec.com/img/202208250855627.jpg" alt="xss004"></p><p>重新加载下页面，依旧会弹出。也是说每个访问该页面的用户都会受到攻击。</p><p><img src="https://image.yeyusec.com/img/202208250855165.jpg" alt="xss005"></p><h2 id="0x03-DOM型xss"><a href="#0x03-DOM型xss" class="headerlink" title="0x03 DOM型xss"></a>0x03 DOM型xss</h2><p>DOM 型 XSS 其实是一种特殊类型的反射型 XSS，它是基于 DOM 文档对象模型的一种漏洞。<br>DOM 就是一个树状的模型，你可以编写 js 代码对树进行操作，比如获取节点的名称，增加一个元素等。DOM树长这样：</p><p><img src="https://image.yeyusec.com/img/202208260816087.jpg" alt="xss008"></p><p>再回到题目本身，可以发现输入框输入的字符为未经过处理而是直接拼接的，代码是<code>&quot;&lt;a href=&#39;&quot;+str+&quot;&#39;&gt;what do you see?&lt;/a&gt;&quot;</code>，那么直接闭合前面的a标签，然后插入恶意代码即可。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;#&#x27;</span> <span class="hljs-attr">onmouseover</span>=<span class="hljs-string">&quot;alert(&#x27;xss&#x27;)&quot;</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="https://image.yeyusec.com/img/202208260820291.jpg" alt="xss009"></p><blockquote><p>onmouseover事件：指鼠标移动都某个指点的HTML标签上，会出现什么效果。<br>onmouseout事件：指鼠标移出某个指点的HTML标签后，会出现什么效果。</p></blockquote><p>好，成功弹出。</p><h2 id="0x04-xss之盲打"><a href="#0x04-xss之盲打" class="headerlink" title="0x04 xss之盲打"></a>0x04 xss之盲打</h2><p>xss盲打在我的理解就是遇见输入框就先输入个弹窗脚本试试，或许就有什么惊喜。</p><p><img src="https://image.yeyusec.com/img/202208260836464.jpg" alt="xss010"></p><p>果不其然，在后台就有了新发现，弹窗成功。</p><p><img src="https://image.yeyusec.com/img/202208260837017.jpg" alt="xss011"></p><h2 id="0x05-xss之过滤"><a href="#0x05-xss之过滤" class="headerlink" title="0x05 xss之过滤"></a>0x05 xss之过滤</h2><p>废话不多说，直接上payload<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>，结果不出所料，直接被吞了。</p><p><img src="https://image.yeyusec.com/img/202208260842538.jpg" alt="xss012"></p><p>推测是做了过滤，那就变一种方式再来。</p><p><img src="https://image.yeyusec.com/img/202208260848371.jpg" alt="xss013"></p><p>看源码实际是利用正则将“&lt;script”替换为空。直接全部换成大写在弹出，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;<span class="hljs-title class_">SCRIpt</span>&gt;<span class="hljs-title class_">ALErt</span>(<span class="hljs-number">11</span>)&lt;<span class="hljs-title class_">SCRipt</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="0x06-xss之htmlspecialchars"><a href="#0x06-xss之htmlspecialchars" class="headerlink" title="0x06 xss之htmlspecialchars"></a>0x06 xss之htmlspecialchars</h2><p>查询资料可知，php的htmlspecialchars()函数是将预定义的字符转换成HTML实体，HTML实体是浏览器用来代替特殊的字符的一种代码。有时候需要在文档内容中这些字符，但是不想让它们作为HTML被处理，为此应该使用这些实体（比如将&lt;小于号转换成&amp;lt；）。比如：</p><blockquote><p>预定义的字符是：</p><ul><li>&amp; （和号）成为 &amp;</li><li>“ （双引号）成为 “</li><li>‘ （单引号）成为 ‘</li><li>&lt; （小于）成为 &lt;</li><li>&gt; （大于）成为 &gt;</li></ul></blockquote><p>另外，函数常用的参数有：</p><blockquote><p>ENT_COMPAT - 默认。仅编码双引号。<br>ENT_QUOTES - 编码双引号和单引号。<br>ENT_NOQUOTES - 不编码任何引号。<br>可以看到，我们的<code>nihao&lt;&gt;h&quot;#&#39;hha</code>被转换成了<code>nihao&amp;lt;&amp;gt;h\&amp;quot;#\&#39;hha</code>，其中单引号并没有被转义，那么我们可以用单引号闭合href结合其他语句进行注入。</p></blockquote><p><img src="https://image.yeyusec.com/img/202209192205206.png" alt="xss001"></p><p><img src="https://image.yeyusec.com/img/202209192207817.png" alt="xss002"></p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme"><span class="hljs-symbol">&#x27;onclick=alert</span>(<span class="hljs-name">11</span>)&#x27;<br></code></pre></td></tr></table></figure><h2 id="0x07-xss之href输出"><a href="#0x07-xss之href输出" class="headerlink" title="0x07 xss之href输出"></a>0x07 xss之href输出</h2><p>这个直接看源码：<img src="https://image.yeyusec.com/img/202209192213882.png" alt="xss004"></p><p>源码中使用了htmlspecialchars的ENT_QUOTES，双引号及单引号以及左右尖括号均会被转义，可以使用javascript伪协议来执行js，payload如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">javascript</span>:<span class="hljs-title function_">alert</span>(<span class="hljs-number">11</span>)<br></code></pre></td></tr></table></figure><blockquote><p>伪协议不同于因特网上所真实存在的协议，如http:&#x2F;&#x2F;，https:&#x2F;&#x2F;，ftp:&#x2F;&#x2F;，</p><p>而是为关联应用程序而使用的.如:tencent:&#x2F;&#x2F;(关联QQ)，data:(用base64编码来在浏览器端输出二进制文件)，还有就是javascript:</p><p>我们可以在浏览地址栏里输入”javascript:alert(‘JS!’);”，点转到后会发现，实际上是把javascript:后面的代码当JavaScript来执行，并将结果值返回给当前页面。</p></blockquote><h2 id="0x08-xss之js输出"><a href="#0x08-xss之js输出" class="headerlink" title="0x08 xss之js输出"></a>0x08 xss之js输出</h2><p>这道题的特点在于我们的输入被带入到js中，对我们输入的数据进行判断再动态生成内容。那么我们注入的话，可以使用单引号以及script标签闭合掉前面的script，再插入自己的注入代码。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;&lt;/script&gt;&lt;script&gt;alert(11)&lt;/script&gt;</span><br></code></pre></td></tr></table></figure><p>成功弹出！！！</p><p><img src="https://image.yeyusec.com/img/202209192233198.png" alt="xss006"></p><h2 id="0x09-总结"><a href="#0x09-总结" class="headerlink" title="0x09 总结"></a>0x09 总结</h2><p>形成XSS漏洞的主要原因是程序对输入和输出的控制不够严格，导致“精心构造”的脚本输入后，在输到前端时被浏览器当作有效代码解析执行从而产生危害。</p><p>因此在XSS漏洞的防范上，一般会采用“对输入进行过滤”和“输出进行转义”的方式进行处理: 输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入; 输出转义：根据输出点的位置对输出到前端的内容进行适当转义;</p><h3 id="XSS常见Payload"><a href="#XSS常见Payload" class="headerlink" title="XSS常见Payload"></a>XSS常见Payload</h3><blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;xss&quot;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">javascript:alert(111)</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">alert(</span>&#x27;<span class="hljs-attr">XSS</span>&#x27;)&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">x</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">alert(1)</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;xss&#x27;)&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><p>其他可参考： <a href="https://www.cnblogs.com/xuehen/p/4814237.html">https://www.cnblogs.com/xuehen/p/4814237.html</a></p>]]></content>
    
    
    <categories>
      
      <category>安全笔记</category>
      
      <category>靶场学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞靶场</tag>
      
      <tag>xss</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pikachu靶场实战之暴力破解（1）</title>
    <link href="/2022/08/18/%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0/pikachu%E9%9D%B6%E5%9C%BA%E5%AE%9E%E6%88%98%E4%B9%8B%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%EF%BC%881%EF%BC%89/"/>
    <url>/2022/08/18/%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0/pikachu%E9%9D%B6%E5%9C%BA%E5%AE%9E%E6%88%98%E4%B9%8B%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="靶场简介"><a href="#靶场简介" class="headerlink" title="靶场简介"></a>靶场简介</h2><p>Pikachu 是一个带有漏洞的Web应用系统，在这里包含了常见的 web 安全漏洞。 如果你是一个 Web 渗透测试学习人员且正发愁没有合适的靶场进行练习，那么 Pikachu 可能正合你意。以上是Pikachu漏洞平台的简介。</p><p>作为像我这种的安全新手，用 Pikachu 入门再好不过了，可供漏洞种类比较多，而且还免费，话不多说，直接开干。</p><h3 id="暴力破解概述"><a href="#暴力破解概述" class="headerlink" title="暴力破解概述"></a>暴力破解概述</h3><p>暴力破解即账号枚举, 攻击者使用自己的用户名和密码字典,对目的服务器进行一个一个尝试登陆,如果字典足够强大,最终就会猜解成功获取到用户名和密码。</p><h2 id="0x01-基于表单的暴力破解"><a href="#0x01-基于表单的暴力破解" class="headerlink" title="0x01 基于表单的暴力破解"></a>0x01 基于表单的暴力破解</h2><p>第一道题比较简单，前后端都没有验证码，输入错误的账号密码会返回一个<code>username or password is not exists</code>的提示。</p><p><img src="https://image.yeyusec.com/img/202208222324751.jpg" alt="baopo001"></p><p>那么，破解的思路就很清晰了，直接使用 burpsuite 的 intruder 进行账号密码暴力破解即可，字典的话，Github上这个字典库貌似很全，<a href="https://github.com/TheKingOfDuck/fuzzDicts">https://github.com/TheKingOfDuck/fuzzDicts</a> 。</p><p><img src="https://image.yeyusec.com/img/202208222342373.jpg" alt="baopo002"></p><p>抓包，将登录页面发送至 intruder ，并在 Positions 中将 username 和 password 设置为 payload，攻击方式选择 Cluster bomb。</p><p><img src="https://image.yeyusec.com/img/202208222342010.jpg" alt="baopo003"></p><blockquote><p>burpsuite 有四种 attack type（攻击方式），分别是</p><ol><li>Sinper（狙击手)：<br> 第一种攻击方式sinper主要是将bp截的包各个用$$符号标记的数据进行逐个遍历替换。</li><li>Battering ram（攻城槌）<br>这种攻击方式是将包内所有标记的数据进行同时替换再发出。</li><li>Pitchfork（干草叉）<br> 多参数同时爆破，但使用的是不同字典。</li><li>Cluster bomb（集束炸弹）<br> 多参数做笛卡尔乘积模式爆破。多个密码本对应多个位置，交叉组合，每一个密码本里的密码都对应于另一密码本所有密码。常用于爆破账号密码。</li></ol></blockquote><p><img src="https://image.yeyusec.com/img/202208222342731.jpg" alt="baopo004"></p><p>接着在 Payloads 模块将两个参数的字典导入，选择 Simple list 模式。</p><p><img src="https://image.yeyusec.com/img/202208222342183.jpg" alt="baopo005"></p><p>由于登录失败有明显的提示，可以将 <code>username or password is not exists</code> 加入到 Grep match 中对尝试登录的结果进行筛选。</p><p><img src="https://image.yeyusec.com/img/202208222342959.jpg" alt="baopo006"></p><p>因为导入的账号和密码字典都是 Top500， 根据 Cluste bomb 攻击模式的特性，尝试爆破次数高达 25 万次。我这小破电脑要跑很久了。下一关就直接用提示的账号密码了，不然要跑太久了。</p><p><img src="https://image.yeyusec.com/img/202208222347300.jpeg" alt="baopo007">最终筛选出 ’admin&#x2F;123456‘ ，’pikachu&#x2F;000000‘，’test&#x2F;abc123‘，这三组密码（ps: pikachu不在字典里，自己加的，哈哈)</p><h2 id="0x02-验证码绕过-on-server"><a href="#0x02-验证码绕过-on-server" class="headerlink" title="0x02 验证码绕过(on server)"></a>0x02 验证码绕过(on server)</h2><p>这关相比第一关多了个验证码，这也是实际操作中经常遇到的。</p><p><img src="https://image.yeyusec.com/img/202208222343739.jpg" alt="baopo2-001"></p><p>抓包可知再不改变验证码的情况下，用burp修改参数验证码一直有效，说明验证码没有跟随服务器更新，可以使用多次。那么接下来的操作步骤和第一关就差不多了。</p><p><img src="https://image.yeyusec.com/img/202208222343670.jpg" alt="baopo2-002"></p><p>设置参数。</p><p><img src="https://image.yeyusec.com/img/202208222343537.jpg" alt="baopo2-003"></p><p>直接攻击，然后就可以得到正确的账户密码了。</p><h2 id="0x03-验证码绕过-on-client"><a href="#0x03-验证码绕过-on-client" class="headerlink" title="0x03 验证码绕过(on client)"></a>0x03 验证码绕过(on client)</h2><p>这关从网页源码可知验证码是前端生成，并且在前端进行校验，这就很离谱。直接抓包，改包，不经过前端就ok了，和上一关操作步骤一模一样。</p><p><img src="https://image.yeyusec.com/img/202208222343776.jpg" alt="baopo3-001"></p><h2 id="0x04-token防爆破"><a href="#0x04-token防爆破" class="headerlink" title="0x04 token防爆破?"></a>0x04 token防爆破?</h2><p>这关的要点在于加入了 token，token 的作用主要是为了防止CSRF（跨站脚本攻击）。</p><p><img src="https://image.yeyusec.com/img/202208222344854.jpg" alt="baopo4-001"></p><p>返回的页面中会携带下一次需要用到的token，那么直接每次请求的时候将 token 取出，带入到下一次请求中即可。</p><p>这里我们的攻击模式需要选择为 Pitchfork。由于是一一对应的关系，字典还需要稍作调整。</p><p><img src="https://image.yeyusec.com/img/202208222344183.jpg" alt="baopo4-002"></p><p>注意由于是上一次的结果会带入到下一次尝试中，所有只能单线程运行，新版的burp是通过设置 resource pool来实现的。</p><p><img src="https://image.yeyusec.com/img/202208222344606.png" alt="baopo4-003"></p><p>另外，提取token使用的是 Grep Extract模块功能，直接选中token value值，即可直接生成提取表达式，贼方便！！！</p><p><img src="https://image.yeyusec.com/img/202208222344752.jpg" alt="baopo4-004"></p><p>最终也是成功获取账号密码，暴力破解关卡完结~~~</p>]]></content>
    
    
    <categories>
      
      <category>安全笔记</category>
      
      <category>靶场学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞靶场</tag>
      
      <tag>暴力破解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>uoload-labs靶场文件上传漏洞通关之路（1）</title>
    <link href="/2022/08/04/%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0/uoload-labs%E9%9D%B6%E5%9C%BA%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E9%80%9A%E5%85%B3%E4%B9%8B%E8%B7%AF%EF%BC%881%EF%BC%89/"/>
    <url>/2022/08/04/%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0/uoload-labs%E9%9D%B6%E5%9C%BA%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E9%80%9A%E5%85%B3%E4%B9%8B%E8%B7%AF%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="靶场简介"><a href="#靶场简介" class="headerlink" title="靶场简介"></a>靶场简介</h2><p>upload-labs是一个使用php语言编写的，专门收集渗透测试和CTF中遇到的各种上传漏洞的靶场。靶场地址：<a href="https://github.com/c0ny1/upload-labs">https://github.com/c0ny1/upload-labs</a> 。<br>搭建环境为winodws 2003 + phpstudy2018（php5.2.17+apache） + 源码，只需将源码放置在www目录，在配置下站点域名管理，过程十分简单。唯一要注意的点就是80端口冲突时，可以改用其他空闲的端口，或者将iis服务（占用80端口）关闭掉。</p><h3 id="关于burpsuite光标对不准问题"><a href="#关于burpsuite光标对不准问题" class="headerlink" title="关于burpsuite光标对不准问题"></a>关于burpsuite光标对不准问题</h3><p>在使用burp抓包时遇到光标对不准的问题，想选中改掉文件名后缀结果光标一直在文字后面。经百度得知是分辨率的问题，我的拯救者是2k屏设置的是125%缩放，而burp并不支持就会导致文字错位。解决方案是直接把字体调大，我调到16pt。至于其他的该启动参数，设置javaw.exe支持高分辨率，我试了都不太行。</p><h2 id="第一关-前端js绕过"><a href="#第一关-前端js绕过" class="headerlink" title="第一关-前端js绕过"></a>第一关-前端js绕过</h2><p>第一关看源码可知网站通过checkfile函数，将上传的php后缀的文件进行了过滤，并且仅仅是在前端进行了过滤。前端JS绕过方式主要有三种：<br>1.修改html源码绕过。下载html源代码，将.php加入到允许上传的文件类型或者直接删除校验函数，然后在form元素中添加action参数指向要上传的地址即可。<br>2.在线修改js绕过。F12直接修改js，没跑通。<br>3.burp修改数据包绕过。该题仅有前端校验，那么我们上传个jpg，然后通过burp抓包修改为php即可。</p><h2 id="第二关-MIME"><a href="#第二关-MIME" class="headerlink" title="第二关-MIME"></a>第二关-MIME</h2><p>根据第二关提示可知这关是在服务端对数据包的MIME进行检查。<br>后端通过<code>$_FILES[&#39;userfile&#39;][&#39;type&#39;]</code>获取到的MIME信息进行文件格式的过滤,<code>$_FILES</code>指的是一个预定义的数组,用来获取通过POST方法上传文件的相关信息,包括文件的原名称、文件的MIME类型、已上传文件的大小等，其中<code>$_FILES[&#39;userfile&#39;][&#39;type&#39;]</code>获取到的是上传文件的 MIME 类型，常见的有image&#x2F;gif、image&#x2F;jpeg。</p><p>在本题中我们只需将上传的 php 脚本文件的 Content-Type 修改为 image&#x2F;jpeg 即可。后端实现过滤源代码如下：</p><p><code>if (($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/jpeg&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/png&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/gif&#39;))</code></p><h2 id="第三关"><a href="#第三关" class="headerlink" title="第三关-"></a>第三关-</h2>]]></content>
    
    
    <categories>
      
      <category>安全笔记</category>
      
      <category>靶场学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞靶场</tag>
      
      <tag>文件上传</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
